/*********************************************************************
	SYSTEM LampSystem
	IMPLEMENTATION LampImpl_cpp
	cip process Lamp file for PROCESS Lamp
	Filename: PROC_Lamp.cpp
	generated by CIP Tool(R)
	
	activated code options:
		C++ code
		use message interface
	            naming option: channel  prefix
	        all types in shell
	        call context error function
	        'unsigned long' for delays
*********************************************************************/

#include "PROC_Lamp.hpp"

namespace lampunit
{

	namespace lampcluster
	{
        
		/** constructors / destructors */
	        PROC_Lamp::PROC_Lamp(
			const char * i_processString,     
			lampunit::cipshell::INTF_ActionMessagePort* i_amp,     
			ciplibrary::INTF_CipError<char >* i_ciperror,     
			ciplibrary::CipTimerQueue<cipmachine::PROC_CipProcess >* i_timerQueue) :     
				INTF_Lamp(i_processString),
				m_ActionMessagePort(i_amp),
				m_ciperror(i_ciperror),
				SELF(*this),
				Lamp(this) ,
				m_timer(ciplibrary::CipTimer<cipmachine::PROC_CipProcess >(this)),
				m_timerQueue(i_timerQueue)
		{
			m_modeString = INTF_LampStrings::modeString(MODE);
			m_stateString = INTF_LampStrings::stateString(STATE);
			m_inputString = INTF_LampStrings::inputString(INTF_LampNames::_no_input_);
			m_outpulseString = INTF_LampStrings::outpulseString(INTF_LampNames::_no_outpulse_);
		}// constructor
		
		/** initialize the pointers to interaction processes */
		void PROC_Lamp::initInteraction(
			void* i_Lamp)
		{
			STATUS = static_cast<INTF_Lamp* >(i_Lamp);
		} // initInteraction()
		/** extension input functions */
		/**
		 * Trigger the process with inpulse TIMEUP_.
		 */
		void PROC_Lamp::TIMEUP_(void)
		{
			m_inputString = ciplibrary::INTF_CommonStrings::commonString(ciplibrary::INTF_CommonNames::TIMEUP_);	
			switch(STATE)
			{
				case delayed:
					STATE = off_;
					m_stateString = INTF_LampStrings::stateString(STATE);
						m_ActionMessagePort->f_C2_Dark();                                                        
				break;
			default:
				break;
			}		
			resetStrings();	
		} // TIMEUP_()
	        
	 	/** 
		 * Trigger the process with inpulse off.
		 */
		void PROC_Lamp::BHV_off(void)
		{ 
			m_inputString = INTF_LampStrings::inputString(INTF_LampNames::ip_off);	
			switch(STATE)
			{
				case on_:
					STATE = delayed;
					m_stateString = INTF_LampStrings::stateString(STATE);
					setTimer(3);    //  DELAY DELAY_OPERATION
				break;
			default:
				break;
			}     		
			resetStrings();
		} // BHV_off()
	
	 	/** 
		 * Trigger the process with inpulse on.
		 */
		void PROC_Lamp::BHV_on(void)
		{ 
			m_inputString = INTF_LampStrings::inputString(INTF_LampNames::ip_on);	
			switch(STATE)
			{
				case delayed:
					STATE = on_;
					m_stateString = INTF_LampStrings::stateString(STATE);
					setTimer(3);    //  DELAY DELAY_OPERATION
				break;
				case off_:
					STATE = on_;
					m_stateString = INTF_LampStrings::stateString(STATE);
						m_ActionMessagePort->f_C2_Bright();                                                        
				break;
			default:
				break;
			}     		
			resetStrings();
		} // BHV_on()
	
		/** extension functions */
		void PROC_Lamp::setTimer(unsigned long i_delay)
		{
			stopTimer();
			m_timer.setDelay(i_delay);
			m_timerQueue->setTimer(&m_timer);
		}
	
		void PROC_Lamp::stopTimer(void)
		{
			m_timerQueue->stopTimer(&m_timer);
		}
	        
	} // namespace lampcluster
} // namespace lampunit
/*********************************************************************
    End of cip process Lamp for PROCESS Lamp
*********************************************************************/
/* Actifsource ID=[1efc54ce-099f-11e3-b902-17aaca85d2fd,242979e4-b786-11ea-9e22-1112d6355503,7848c6d5-b785-11ea-9e22-1112d6355503,06ed7fd9-b786-11ea-9e22-1112d6355503,242979e3-b786-11ea-9e22-1112d6355503,242979e2-b786-11ea-9e22-1112d6355503,7848c70f-b785-11ea-9e22-1112d6355503,7848c705-b785-11ea-9e22-1112d6355503,/5chOlgVutyadDvc0cQ5qYc9wZM=] */
