/*********************************************************************
	SYSTEM LampSystem
	IMPLEMENTATION LampImpl_cpp
	cip machine header file for CIP MACHINE mLampUnit
	Filename: CIPM_mLampUnit.hpp
	generated by CIP Tool(R)
	
	activated code options:
		C++ code
		use message interface
	            naming option: channel  prefix
	        all types in shell
	        call context error function
	        'unsigned long' for delays
*********************************************************************/

#if !defined(__CIPM_mLampUnit__)
    #define __CIPM_mLampUnit__

#include "INTF_Constant.hpp"
#include "INTF_ActionMessagePort.hpp"
#include "INTF_ErrorHandler.hpp"
#include "INTF_CipError.hpp"          
#include "INTF_mLampUnit.hpp"
#include "INTF_ReadNames.hpp"
#include "LOCAL_QueueData.hpp"
#include "INTF_Button.hpp"
#include "INTF_Lamp.hpp"
#include "CipTimerQueue.hpp"
#include "CipChainQueue.hpp"
#include "CipAutoQueue.hpp"
#include "CipReadQueue.hpp"

namespace lampunit
{
	namespace cipmachine
	{
        
		/** 
		* class CIPM_mLampUnit
		* cip machine for unit LampUnit
		*/
		class CIPM_mLampUnit : 
			public lampunit::cipshell::INTF_mLampUnit, 
			public lampunit::cipshell::INTF_Constant
		{
		public: 
            
			/** consructors / destructors */
			CIPM_mLampUnit(
				lampunit::cipshell::INTF_ActionMessagePort* i_amp,
				ciplibrary::INTF_ErrorHandler<char >* i_ehd);
	
			CIPM_mLampUnit(void){}
	
			virtual ~CIPM_mLampUnit(void);
	
			/** event message interface */
			/** 
			* Triggers CIP Machine by input message Push (channel ButtonEvents).
			* @calls  ERR_CipError
			*/
			virtual void C1_Push(void);
	            
			/** 
			* Triggers CIP Machine by input message Release (channel ButtonEvents).
			* @calls  ERR_CipError
			*/
			virtual void C1_Release(void);
	            
			/** extension interface */
			
			/** 
			* Triggers CIP Machine to increment time by one tick.
			*/
			virtual void TICK_(void);
	            
			/** 
			* Triggers CIP Machine to execute one pending internal activation.
			*  Search order: CHAIN_, TIMEUP_, READ_
			* @calls  ERR_CipError  --  for READ_ activation only
			*/
			virtual void STEP_(void);
	            
			/** 
			* Triggers CIP Machine to execute one pending timeup activation.
			*/
			virtual void TIMEUP_(void);
	            
			/** 
			* Triggers CIP Machine to execute one pending chain activation.
			*/
			virtual void CHAIN_(void);
	            
			/** 
			* Trigger CIP Machine to execute one internally buffered message.
			* @calls  ERR_CipError
			*/
			virtual void READ_(void);
	            
			/** 
			* Trigger CIP Machine to execute one AUTO_
			*/
			virtual void AUTO_(void);
	
			/** 
			* Test if any local step activation is pending and return the result.
			* @return  if local step activation is pending.
			*/
			virtual bool hasSTEP_(void);
	            
			/** 
			* Test if a chain activation is pending and return the result.
			* @return  if a chain activation is pending.
			*/
			virtual bool hasCHAIN_(void);
	            
			/** 
			* Test if a timeup activation is pending and return the result.
			* @return  if a timeup activation is pending.
			*/
			virtual bool hasTIMEUP_(void);
	            
			/** 
			* Test if a read activation is pending and return the result.
			* @return  if a read activation is pending.
			*/
			virtual bool hasREAD_(void);
	            
			/** 
			* Test if an auto activation is pending and return the result.
			* @return  if a auto activation is pending.
			*/
			virtual bool hasAUTO_(void);
	
		private: 
	            
			/** prohibitted default functions */
	
			CIPM_mLampUnit(const CIPM_mLampUnit&);
			CIPM_mLampUnit& operator=(const CIPM_mLampUnit&);
	
	
			/** member variables */
	            
			/** user implemented output message handler */
			lampunit::cipshell::INTF_ActionMessagePort* m_ActionMessagePort;
	            
	
			/** Context Error  */
			ciplibrary::INTF_CipError<char >* m_ciperror;
	            
			/** timer queue */
			ciplibrary::CipTimerQueue<cipmachine::PROC_CipProcess > m_timerQueue;
	            
			/** chain queue */
			ciplibrary::CipChainQueue<cipmachine::PROC_CipProcess > m_chainQueue;
	            
			/** auto queue */
			ciplibrary::CipAutoQueue<cipmachine::PROC_CipProcess > m_autoQueue;
	            
			/** read queue */
			ciplibrary::CipReadQueue<ciplibrary::CipRead<cipmachine::LOCAL_QueueData, cipmachine::INTF_ReadNames::E_Reads, cipmachine::PROC_CipProcess >, ciplibrary::INTF_CipError<char > >* m_readQueue;
	 
			/** Status vectors of cluster LampCluster */
	
			/** Process Button */
			lampunit::lampcluster::INTF_Button* Button;
	            
			/** Process Lamp */
			lampunit::lampcluster::INTF_Lamp* Lamp;
	            
		}; // class CIPM_mLampUnit

	} // namespace cipmachine
} // namespace lampunit

#endif // __CIPM_mLampUnit__

/*********************************************************************
    End of cip machine header for CIP MACHINE mLampUnit
*********************************************************************/

/* Actifsource ID=[65dba398-0beb-11e3-b115-a3f7f19b76fe,242979e4-b786-11ea-9e22-1112d6355503,7848c6d5-b785-11ea-9e22-1112d6355503,06ed7fd9-b786-11ea-9e22-1112d6355503,242979e3-b786-11ea-9e22-1112d6355503,242979e2-b786-11ea-9e22-1112d6355503,TAPN6YhsEJAEfT4By+NXt5ntIng=] */
