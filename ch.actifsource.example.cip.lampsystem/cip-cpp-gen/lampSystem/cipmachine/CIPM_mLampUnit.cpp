/*********************************************************************
	SYSTEM LampSystem
	IMPLEMENTATION LampImpl_cpp
	cip machine file for CIP MACHINE mLampUnit
	Filename: CIPM_mLampUnit.cpp
	generated by CIP Tool(R)
	
	activated code options:
		C++ code
		use message interface
	            naming option: channel  prefix
	        all types in shell
	        call context error function
	        'unsigned long' for delays
*********************************************************************/

#include "CIPM_mLampUnit.hpp"
#include "ERR_CipError.hpp"
#include "PROC_Button.hpp"
#include "PROC_Lamp.hpp"
#include <stdio.h>


namespace lampunit
{
	namespace cipmachine
	{
        
		/** consructors / destructors */
		CIPM_mLampUnit::CIPM_mLampUnit(
			lampunit::cipshell::INTF_ActionMessagePort* i_amp,
			ciplibrary::INTF_ErrorHandler<char >* i_ehd) :
			m_ActionMessagePort(i_amp) 
		{
			TIME = 0;
			m_ciperror = new ciplibrary::ERR_CipError<char >(i_ehd);                               
			m_readQueue = new ciplibrary::CipReadQueue<ciplibrary::CipRead<cipmachine::LOCAL_QueueData, cipmachine::INTF_ReadNames::E_Reads, cipmachine::PROC_CipProcess >, ciplibrary::INTF_CipError<char > >(1);
			char l_processString[18];

			sprintf(l_processString, "Button           ");
			Button =
				new lampunit::lampcluster::PROC_Button(          
					l_processString,
					m_ActionMessagePort,
					m_ciperror);
			sprintf(l_processString, "Lamp             ");
			Lamp =
				new lampunit::lampcluster::PROC_Lamp(          
					l_processString,
					m_ActionMessagePort,
					m_ciperror,
					&m_timerQueue);
			Button->initInteraction(Button, Lamp);
			Lamp->initInteraction(Lamp);
		} // constructor

		CIPM_mLampUnit::~CIPM_mLampUnit(void)
		{
        
			delete Button;	
			delete Lamp;	
			delete m_ciperror;
			delete m_readQueue;
		} // destructor

		/** event messages */
		/**
		* Triggers CIP Machine by input message Push (channel ButtonEvents).
		* @calls  ERR_CipError
		*/
		void CIPM_mLampUnit::C1_Push (void)
		{
			 Button->C1_Push();
		} // C1_Push()
		
		/**
		* Triggers CIP Machine by input message Release (channel ButtonEvents).
		* @calls  ERR_CipError
		*/
		void CIPM_mLampUnit::C1_Release (void)
		{
			 Button->C1_Release();
		} // C1_Release()
		
		/** extension functions */
		/** 
		* Triggers CIP Machine to increment time by one tick.
		*/
		void CIPM_mLampUnit::TICK_(void)
		{
			TIME += 1;
			m_timerQueue.TICK_();
		} // TICK_()

		/** 
		* Triggers CIP Machine to execute one pending internal activation.
		*  Search order: CHAIN_, TIMEUP_, READ_
		* @calls  ERR_CipError  --  for READ_ activation only
		*/
		void CIPM_mLampUnit::STEP_(void)
		{
			if (m_chainQueue.hasCHAIN_())
			{
				m_chainQueue.CHAIN_();
			}
			else if (m_timerQueue.hasTIMEUP_())
			{
				m_timerQueue.TIMEUP_();
			}
			else if (m_autoQueue.hasAUTO_())
			{
				m_autoQueue.AUTO_();
			}
			else if (m_readQueue->hasREAD_())
			{
				m_readQueue->READ_();
			}
			else 
			{
				return;
			}
		} // STEP_()

		/** 
		* Triggers CIP Machine to execute one pending timeup activation.
		*/
		void CIPM_mLampUnit::TIMEUP_(void)
		{
			m_timerQueue.TIMEUP_();
		} // TIMEUP_()

		/** 
		* Triggers CIP Machine to execute one pending chain activation.
		*/
		void CIPM_mLampUnit::CHAIN_(void)
		{
			m_chainQueue.CHAIN_();
		} // CHAIN_()
  
		/** 
		* Trigger CIP Machine to execute one internally buffered message.
		* @calls  ERR_CipError
		*/
		void CIPM_mLampUnit::READ_(void)
		{
			if (m_readQueue->hasREAD_())
			{
				m_readQueue->READ_();
			}
			else 
			{
				m_autoQueue.AUTO_();
			}
		} // READ_()

		/** 
		* Trigger CIP Machine to execute one AUTO_
		*/
		void CIPM_mLampUnit::AUTO_(void)
		{
			m_autoQueue.AUTO_();
		} // AUTO_()

		/** 
		* Test if any local step activation is pending and return the result.
		* @return  if local step activation is pending.
		*/
		bool CIPM_mLampUnit::hasSTEP_(void)
		{
			return m_chainQueue.hasCHAIN_() || 
				m_timerQueue.hasTIMEUP_() || 
				m_autoQueue.hasAUTO_() || 
				m_readQueue->hasREAD_();
		} // hasSTEP_()
        
		/** 
		* Test if a chain activation is pending and return the result.
		* @return  if a chain activation is pending.
		*/
		bool CIPM_mLampUnit::hasCHAIN_(void)
		{
			return m_chainQueue.hasCHAIN_();
		} // hasCHAIN_()
        
		/** 
		* Test if a timeup activation is pending and return the result.
		* @return  if a timeup activation is pending.
		*/
		bool CIPM_mLampUnit::hasTIMEUP_(void)
		{
			return m_timerQueue.hasTIMEUP_();
		} // hasTIMEUP_()
        
		/** 
		* Test if a read activation is pending and return the result.
		* @return  if a read activation is pending.
		*/
		bool CIPM_mLampUnit::hasREAD_(void)
		{
			return m_readQueue->hasREAD_();
		} // hasREAD_()
        
		/** 
		* Test if an auto activation is pending and return the result.
		* @return  if a auto activation is pending.
		*/
		bool CIPM_mLampUnit::hasAUTO_(void)
		{
			return m_autoQueue.hasAUTO_();
		} // hasAUTO_()

	} // namespace cipmachine
} // namespace lampunit

/*********************************************************************
    End of cip machine for CIP MACHINE mLampUnit
*********************************************************************/
/* Actifsource ID=[77fe41ec-08ae-11e3-b902-17aaca85d2fd,242979e4-b786-11ea-9e22-1112d6355503,7848c6d5-b785-11ea-9e22-1112d6355503,06ed7fd9-b786-11ea-9e22-1112d6355503,242979e3-b786-11ea-9e22-1112d6355503,242979e2-b786-11ea-9e22-1112d6355503,D/S6Fh615vTuP8bfR3dA8TCAb/s=] */
