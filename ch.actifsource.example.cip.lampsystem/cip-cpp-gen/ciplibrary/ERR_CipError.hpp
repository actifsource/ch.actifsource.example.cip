/*********************************************************************
	SYSTEM CIPLIBRARY
	cip error header file 
	Filename: ERR_CipError.hpp
	generated by CIP Tool(R)
	activated code options:
		C++ code
*********************************************************************/

#if !defined(__ERR_CipError__)
	#define __ERR_CipError__

#include "INTF_ErrorHandler.hpp"
#include "INTF_CipError.hpp"
#include <iostream>

namespace ciplibrary
{
	
	/** 
	 * class ERR_CipError
	 * cip error information.
	 */
	
	template<class C >
	class ERR_CipError : 
		public INTF_CipError<C >
	{
	public: 
		
		/** consructors / destructors */
		ERR_CipError(INTF_ErrorHandler<C >*);
		virtual ~ERR_CipError(void){}

		
		/** member access functions */
		virtual C* getProcess(void);
		virtual C* getMode(void);
		virtual C* getState(void);
		virtual C* getInput(void);
		virtual C* getChannel(void);
		virtual C* getOutput(void);
		virtual C* getReceiver(void);
		virtual void reset(void);
		
		/** Error call functions */
		virtual void call_ContextError(C* i_process, C* i_mode, C* i_state, C* i_input);
		virtual void call_BufferWarning(void);
		virtual void call_BufferError(C* i_channel, C* i_message);
		virtual void call_PulseSelectionError(C* i_process, C* i_mode, C* i_state, C* i_outpulse, C* i_receiver);
		virtual void call_MessageSelectionError(C* i_process, C* i_mode, C* i_state, C* i_channel, C* i_message);
		
		/** Trace functions */
		virtual std::ostream& print(std::ostream& os) const;

	private: 
		
		/** prohibitted default functions */
		ERR_CipError(const ERR_CipError&);
		ERR_CipError& operator=(const ERR_CipError&);

		
		/** member variables */
		INTF_ErrorHandler<C >* m_ErrorHandler;
		C* m_process;
		C* m_mode;
		C* m_state;
		C* m_input;
		C* m_channel;
		C* m_output;
		C* m_receiver;
	}; // class ERR_CipError

/*********************************************************************
	Template implementation
*********************************************************************/

	
	/** consructors / destructors */
	template<class C >
	ERR_CipError<C >::ERR_CipError(INTF_ErrorHandler<C >* i_ehd) : 
		m_ErrorHandler(i_ehd)
	{
		m_process = "";
		m_mode = "";
		m_state = "";
		m_input = "";
		m_output = "";
		m_channel = "";
		m_receiver = "";
	} // constructor()
	
	/** member access functions */
	template<class C >
	C* ERR_CipError<C >::getProcess(void)
	{
		return m_process;
	} // getProcess()

	template<class C >
	C* ERR_CipError<C >::getMode(void)
	{
		return m_mode;
	} // getMode()

	template<class C >
	C* ERR_CipError<C >::getState(void)
	{
		return m_state;
	} // getState()

	template<class C >
	C* ERR_CipError<C >::getInput(void)
	{
		return m_input;
	} // getInput()

	template<class C >
	C* ERR_CipError<C >::getChannel(void)
	{
		return m_channel;
	} // getChannel()

	template<class C >
	C* ERR_CipError<C >::getOutput(void)
	{
		return m_output;
	} // getOutput()

	template<class C >
	C* ERR_CipError<C >::getReceiver(void)
	{
		return m_receiver;
	} // getReceiver()

    
	template<class C >
	void ERR_CipError<C >::reset(void)
	{
		m_process = "";
		m_mode = "";
		m_state = "";
		m_input = "";
		m_output = "";
		m_channel = "";
		m_receiver = "";
	} // reset()

	/** Error call functions */
	template<class C >
	void ERR_CipError<C >::call_ContextError(C* i_process, C* i_mode, C* i_state, C* i_input)
	{
		m_process = i_process;
		m_mode = i_mode;
		m_state = i_state;
		m_input = i_input;
		m_ErrorHandler->handle_ContextError(this);
		reset();
	} // call_ContextError()

	template<class C >
	void ERR_CipError<C >::call_BufferWarning(void)
	{
		m_ErrorHandler->handle_BufferWarning(this);
		reset();
	} // call_BufferWarning()

	template<class C >
	void ERR_CipError<C >::call_BufferError(C* i_channel, C* i_message)
	{
		m_channel = i_channel;
		m_output = i_message;
		m_ErrorHandler->handle_BufferError(this);
		reset();
	} // call_BufferError()

	template<class C >
	void ERR_CipError<C >::call_PulseSelectionError(C* i_process, C* i_mode, C* i_state, C* i_outpulse, C* i_receiver)
	{
		m_process = i_process;
		m_mode = i_mode;
		m_state = i_state;
		m_output = i_outpulse;
		m_receiver = i_receiver;
		m_ErrorHandler->handle_PulseSelectionError(this);
		reset();
	} // call_PulseSelectionError()

	template<class C >
	void ERR_CipError<C >::call_MessageSelectionError(C* i_process, C* i_mode, C* i_state, C* i_channel, C* i_message)
	{
		m_process = i_process;
		m_mode = i_mode;
		m_state = i_state;
		m_channel = i_channel;
		m_output = i_message;
		m_ErrorHandler->handle_MessageSelectionError(this);
		reset();
	} // call_MessageSelectionError()

	
	/** Trace functions */
	template<class C >
	std::ostream& ERR_CipError<C >::print(std::ostream& os) const
	{
		os << m_process;
		if (*m_mode != 0) {os << "\n\tmode " << m_mode;}
		if (*m_state != 0) {os << "\n\tstate " << m_state;}
		if (*m_input != 0) {os << "\n\tinput " << m_input;}
		if (*m_channel != 0) {os << "\n\tchannel " << m_channel;}
		if (*m_output != 0) {os << "\n\toutput " << m_output;}
		if (*m_receiver != 0) {os << "\n\treceiver " << m_receiver;}
		return os;
	} // print()

} // namespace ciplibrary

#endif // __ERR_CipError__

/*********************************************************************
	End of cip error header
*********************************************************************/
/* Actifsource ID=[00e6b1ce-08ad-11e3-b902-17aaca85d2fd,a6d1b8c9-cedd-11de-80c2-87ac3b08f930,1URXYGabEfNQ5ReXzLqsF4cvLeE=] */
