/*********************************************************************
	SYSTEM CIPLIBRARY
	cip list header file 
	Filename: CipList.hpp
	generated by CIP Tool(R)
	activated code options:
		C++ code
*********************************************************************/

#if !defined(__CipList__)
	#define __CipList__

namespace ciplibrary
{
	// forward declaration
	template<class T > class CipListIterator;
	
	/** 
	 * class CipList
	 * A single linked list that stores pointers to buckets provided by the user.
	 * The bucket pointers are not deleted in the destructor.
	 * The bucket must provide a function to get the NextPointer with the signature
	 * T*& (T::*T_pFnGetLink)() where T is the type of the bucket.
	 */
	template<class T >
	class CipList
	{
	public: 

		/** The Iterator for sequential access. */
		typedef CipListIterator<T > Iterator;

		/** the pointer to the function getting the next bucket. */
		typedef T*& (T::*T_pFnGetNext)();
		
		/** 
		 * Consructor
		 * @param i_pFnGetNextFunction pointer to the function in the bucket
		 * 		that returns apointer to the next element
		 */
		explicit CipList(T_pFnGetNext i_pFnGetNext) : 
			m_pFnGetNext(i_pFnGetNext), 
			m_paFront(0), 
			m_paBack(0)
		{}
		
		/** 
		 * Copy Consructor
		 * @param i_object
		 * @warning Just the basic pointers are copied, not the data in the list!
		 */
		CipList(const CipList& i_object);
		
		/** 
		 * Assignment operator
		 * @param i_object
		 * @warning Just the basic pointers are copied, not the data in the list!
		 */
		CipList& operator=(const CipList& i_object);
		
		/** 
		 * Adds an element at the end of the list
		 * @param i_element Poiner to the element to be inserted.
		 * @warning i_element must be a valid pointer to an element in the list
		 */
		void push_back(T* i_element);
		
		/** 
		 * Adds an element to the front of the list
		 * @param i_element Pointer to the bucket to insert.
		 * @warning i_element must be a valid pointer to an element of the list
		 */
		void push_front(T* i_element);
		
		/** 
		 * Removes an element from the front of the list
		 * @return Poiner to the first element in the list, or 0 if the list is empty.
		 */
		T* pop_front(void);
		
		/** 
		 * Gets a pointer to the first element in the list
		 * @return Poiner to the first element in the list, or 0 if the list is empty.
		 */
		T* front(void);
		
		/** 
		 * Gets a const pointer to the first element in the list
		 * @return const Poiner to the first element in the list, or 0 if the list is empty.
		 */
		const T* front(void) const;
		
		/** 
		 * Answer whether the element is in the list.
		 * @param i_element the element to search.
		 * @return true if the element is found; false otherwise.
		 */
		bool lookup(T& i_element);
		
		/** 
		 * Removes the element from the list.
		 * @param i_element the element to remove.
		 * @return true if the element is found and removed; false otherwise.
		 */
		bool remove(T* i_element);
		
		/** 
		 * Inserts a new element after an existing one
		 * @param i_element the element after that is placed the new element.
		 * @param i_newElement the new element.
		 * @warning this method does not test whether i_element is in the list.
		 * 		Make shure that the pointers are not NULL
		 */
		void insertAfter(T* i_element, T* i_newElement);
		
		/** 
		 * Answer whether the list is empty.
		 * @return true if the list is empty; false otherwise.
		 */
		bool empty(void) const;
		
		/** 
		 * Answer the size of the list.
		 * @return the size of the list.
		 */
		unsigned long size(void);

	private: 

		/** Iterator needs access to getNext() */
		friend class CipListIterator<T >;
		
		/** 
		 * Gets the next element after the parameter element.
		 * @param i_element poiner to the element.
		 * @return list element.
		 */
		T*& getNext(T* i_element);
		
		/** 
		 * Gets the next const element after the parameter element.
		 * @param i_element const poiner to the element.
		 * @return const list element.
		 */
		const T*& getNext(const T* i_element) const;
		
		/** 
		 * Unlinks a node from the list.
		 * @param i_node the poiner to unlink.
		 * @return the unlinked pointer
		 */
		T* unlinkNodeFromList(T*& i_node);
		
		/** 
		 * Links a new node into the list.
		 * @param i_node the poiner after which the new node is linked.
		 * @param i_newNode the the new node.
		 */
		void linkNodeIntolist(T*& i_node, T* i_newNode);

		
		/** member variables */
		T_pFnGetNext m_pFnGetNext;
		T* m_paFront;
		T* m_paBack;

	}; // class CipList

/*********************************************************************
*********************************************************************/


	template<class T >
	CipList<T >::CipList(const CipList<T >& i_object)
	{
		m_pFnGetNext = i_object.m_pFnGetNext;
		m_paFront = i_object.m_paFront;
		m_paBack = i_object.m_paBack;
	} // Copy Constructor()

	template<class T >
	CipList<T >& CipList<T >::operator=(const CipList<T >& i_object)
	{
		m_pFnGetNext = i_object.m_pFnGetNext;
		m_paFront = i_object.m_paFront;
		m_paBack = i_object.m_paBack;
	} // operator=()

	template<class T >
	void CipList<T >::push_back(T* i_element)
	{
		if (m_paBack)
		{
			// add ad node to the end of the list
			linkNodeIntolist(getNext(m_paBack), i_element);
		}
		else 
		{
			// list is empty; add a node at the front of the list
			linkNodeIntolist(m_paFront, i_element);
		}
	} // push_back()

	template<class T >
	void CipList<T >::push_front(T* i_element)
	{
		linkNodeIntolist(m_paFront, i_element);
	} // push_front()

	template<class T >
	T* CipList<T >::pop_front(void)
	{
		return unlinkNodeFromList(m_paFront);
	} // pop_front()

	template<class T >
	T* CipList<T >::front(void)
	{
		return m_paFront;
	} // front()

	template<class T >
	const T* CipList<T >::front(void) const
	{
		return m_paFront;
	} // front() const 

	template<class T >
	bool CipList<T >::lookup(T& i_element)
	{
		T* l_next = m_paFront;
		while (l_next)
		{
			if (l_next == &i_element)
			{
				return true;
			}
			l_next = getNext(l_next);
		}
		return false;
	} // lookup()

	template<class T >
	bool CipList<T >::remove(T* i_element)
	{
		T** l_next = &m_paFront;
		while (*l_next)
		{
			if (*l_next == i_element)
			{
				unlinkNodeFromList(*l_next);
				return true;
			}
			l_next = &getNext(*l_next);
		}
		return false;
	} // remove()

	template<class T >
	void CipList<T >::insertAfter(T* i_element, T* i_newElement)
	{
		if (i_element == 0)
		{
			push_front(i_newElement);
		}
		else 
		{
			linkNodeIntolist(getNext(i_element), i_newElement);
		}
	} // insertAfter()

	template<class T >
	bool CipList<T >::empty(void) const
	{
		return m_paBack == 0;
	} // empty()

	template<class T >
	unsigned long CipList<T >::size(void)
	{
		if (m_paBack)
		{
			unsigned long n = 1;
			T* l_ptr = m_paFront;
			while (l_ptr != m_paBack)
			{
				++n;
				l_ptr = getNext(l_ptr);
			}
			return n;
		}
		else 
		{
			return 0;
		}
	} // size()

	template<class T >
	T*& CipList<T >::getNext(T* i_element)
	{
		return (i_element->*m_pFnGetNext)();
	} // getNext()

	template<class T >
	const T*& CipList<T >::getNext(const T* i_element) const
	{
		return (const_cast<T*>(i_element)->*m_pFnGetNext)();
	} // getNext() const 

	template<class T >
	T* CipList<T >::unlinkNodeFromList(T*& i_node)
	{
		if (i_node == 0) 
		{
			return 0;
		}
		T* l_freenode = i_node;
		i_node = getNext(i_node);
		
		// set next pointer of removed node to 0
		getNext(l_freenode) = 0;
		
		// in case the last element has been removed, correct m_paBack.
		if (l_freenode == m_paBack)
		{
			T* l_tempnode = m_paFront;
			if (l_tempnode)
			{
				do 
				{
					m_paBack = l_tempnode;
					l_tempnode = getNext(l_tempnode);
				}
				while (l_tempnode);
			}
			else 
			{
				// list is empty
				m_paBack = 0;
			}
		}
		return l_freenode;
	} // unlinkNodeFromList()

	template<class T >
	void CipList<T >::linkNodeIntolist(T*& i_node, T* i_newNode)
	{
		// set next pointer to 0 to allow check of last nodeby unlinkNodeFromList()
		getNext(i_newNode);
		
		// !m_paBack -> list is empty.
		// !i_node -> actual element is last in the list
		if (!m_paBack || !i_node)
		{
			m_paBack = i_newNode;
		}
		getNext(i_newNode) = i_node;
		i_node = i_newNode;
	} // linkNodeIntolist()

} // namespace ciplibrary

#endif // __CipList__

/*********************************************************************
	End of cip list header
*********************************************************************/
/* Actifsource ID=[21659898-08ac-11e3-b902-17aaca85d2fd,a6d1b8c9-cedd-11de-80c2-87ac3b08f930,JKtnddl2J4zUiLRZ2TuPe03hF5c=] */
