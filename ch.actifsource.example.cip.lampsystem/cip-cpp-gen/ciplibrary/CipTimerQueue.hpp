/*********************************************************************
	SYSTEM CIPLIBRARY
	cip timer queue header file 
	Filename: CipTimerQueue.hpp
	generated by CIP Tool(R)
	activated code options:
		C++ code
*********************************************************************/

#if !defined(__CipTimerQueue__)
	#define __CipTimerQueue__

#include "CipList.hpp"
#include "CipListIterator.hpp"
#include "CipTimer.hpp"

namespace ciplibrary
{
	
	/** 
	 * class CipTimerQueue
	 * linked list for timer elements as random access queue
	 */
	
	template<class P >
	class CipTimerQueue
	{
	public: 
		
		/** consructors / destructors */
		CipTimerQueue(void);
		virtual ~CipTimerQueue(void){}
		
		/** insert the timer element at the correct position into the queue. */
		void setTimer(CipTimer<P >* i_timer);
		
		/** stop the timer element and remove it form the queue. */
		void stopTimer(CipTimer<P >* i_timer);
		
		/** trigger the process with TIMEUP_ */
		void TIMEUP_(void);
		
		/** increment time and recalculate remaining delays */
		void TICK_(void);
		
		/** return whether any timer element is elapsed */
		bool hasTIMEUP_(void) const;

	private: 
		
		/** prohibitted default functions */
		CipTimerQueue(const CipTimerQueue&);
		CipTimerQueue& operator=(const CipTimerQueue&);

		
		/** member variables */
		CipList<CipTimer<P > > m_list;

	}; // class CipTimerQueue

/*********************************************************************
*********************************************************************/

	
	/** consructors / destructors */
	template<class P >
	CipTimerQueue<P >::CipTimerQueue(void) : 
		m_list(&CipTimer<P >::getNext)
	{} // constructor()
	
	/** insert the timer element at the correct position into the queue. */
	template<class P >
	void CipTimerQueue<P >::setTimer(CipTimer<P >* i_timer)
	{
		unsigned long remainingDelay = i_timer->getDelay();
		typename CipList<CipTimer<P > >::Iterator it(m_list);
		typename CipList<CipTimer<P > >::Iterator lastit(m_list);

		if (m_list.empty())
		{
			i_timer->setRestartDelay(remainingDelay);
			m_list.push_back(i_timer);
			return;
		}
		if (m_list.lookup(*i_timer))
		{
			if (i_timer->getNext() != 0)
			{
				CipTimer<P >* nextTimer = i_timer->getNext();
				nextTimer->setDelay(nextTimer->getDelay() + i_timer->getRestartDelay());
				nextTimer->setRestartDelay(nextTimer->getDelay());
			}
			m_list.remove(i_timer);
		}
		while (++it)
		{
			if (it.val()->getDelay() > remainingDelay)
			{
				it.val()->decreaseDelay(remainingDelay);
				i_timer->setDelay(remainingDelay);
				it.val()->decreaseRestartDelay(remainingDelay);
				i_timer->setRestartDelay(remainingDelay);
				m_list.insertAfter(lastit.val(), i_timer);
				return;
			}
			else 
			{
				remainingDelay -= it.val()->getDelay();
				++lastit;
			}
		}// while list not at end

		i_timer->setDelay(remainingDelay);
		i_timer->setRestartDelay(remainingDelay);
		m_list.push_back(i_timer);
	} // setTimer()
	
	/** stop the timer element and remove it form the queue. */
	template<class P >
	void CipTimerQueue<P >::stopTimer(CipTimer<P >* i_timer)
	{
		if (m_list.empty())
		{
			return;
		}
		if (i_timer->getNext() != 0)
		{
			CipTimer<P >* nextTimer = i_timer->getNext();
			nextTimer->setDelay(nextTimer->getDelay() + i_timer->getDelay());
			nextTimer->setRestartDelay(nextTimer->getDelay());
		}
		m_list.remove(i_timer);
	} // stopTimer()
	
	/** trigger the process with TIMEUP_ */
	template<class P >
	void CipTimerQueue<P >::TIMEUP_(void)
	{
		if (m_list.empty())
		{
			return;
		}
		if (m_list.front()->getDelay() == 0)
		{
			m_list.pop_front()->TIMEUP_();
		}
	} // TIMEUP_()
	
	/** increment time and recalculate remaining delays */
	template<class P >
	void CipTimerQueue<P >::TICK_(void)
	{
		typename CipList<CipTimer<P > >::Iterator it(m_list);
		if (m_list.empty())
		{
			return;
		}
		while (++it)
		{
			if (it.val()->getDelay() > 0)
			{
				it.val()->decrementDelay();
				it.val()->decrementRestartDelay();
				return;
			} // pending timer
		} // while list not at end
	} // TICK_()
	
	/** return whether any timer element is elapsed */
	template<class P >
	bool CipTimerQueue<P >::hasTIMEUP_(void) const
	{
		if (m_list.empty())
		{
			return false;
		}
		else 
		{
			return m_list.front()->getDelay() == 0;
		}
	} // hasTIMEUP_()

} // namespace ciplibrary

#endif // __CipTimerQueue__

/*********************************************************************
	End of cip timer queue header
*********************************************************************/
/* Actifsource ID=[df2f901e-08ac-11e3-b902-17aaca85d2fd,a6d1b8c9-cedd-11de-80c2-87ac3b08f930,Ow7yhIUqYpakwkbO1bUbmq2ydco=] */
