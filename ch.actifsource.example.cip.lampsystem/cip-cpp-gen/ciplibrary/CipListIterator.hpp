/*********************************************************************
	SYSTEM CIPLIBRARY
	cip list iterator header file 
	Filename: CipListIterator.hpp
	generated by CIP Tool(R)
	activated code options:
		C++ code
*********************************************************************/

#if !defined(__CipListIterator__)
	#define __CipListIterator__

namespace ciplibrary
{
	// forward declaration
	template<class T > class CipList;
	
	/** 
	 * class CipListIterator
	 * The Iterator used to iterate over a CipList
	 */
	template<class T >
	class CipListIterator
	{
	public: 
		
		/** 
		 * Consructor
		 * @param i_ciplist The iterator will be placed on this list
		 */
		CipListIterator(CipList<T >& i_ciplist);
		
		/** Default Consructor */
		CipListIterator(void) : 
			m_current(0)
		{}
		
		/** 
		 * Moves the CipListIterator to the next element.
		 * @return Pointer to the next element or 0 if out of range
		 */
		T* operator++(void);
		
		/** 
		 * Moves the CipListIterator i_steps elements forward.
		 * @return Pointer to the found element or 0 if out of range
		 */
		T* operator+=(int i_steps);
		
		/** 
		 * @return Pointer to the actual element
		 */
		T* operator->(void);
		
		/** 
		 * Resets the iterator.
		 */
		void reset(void);
		
		/** 
		 * Resets the iterator and binds it to a new list.
		 * @param i_ciplist The new list of the iterator.
		 */
		void reset(CipList<T >& i_ciplist);
		
		/** 
		 * @return Pointer to the actual element
		 */
		T* val(void);
		
		/** Tests whether the iterator is valid
		 * @return true if the iterator is valid; else if out of range
		 */
		bool isValid(void) const;

	private: 
		
		/** member variables */
		CipList<T >* m_paList;
		bool m_Deleted;
		T* m_current;

	}; // class CipListIterator

/*********************************************************************
*********************************************************************/


	template<class T >
	CipListIterator<T >::CipListIterator(CipList<T >& i_ciplist) : 
		m_paList(&i_ciplist), 
		m_Deleted(false), 
		m_current(0)
	{}


	template<class T >
	T* CipListIterator<T >::operator++(void)
	{
		if (m_Deleted)
		{
			m_Deleted = false;
			return m_current;
		}
		if (m_current)
		{
			m_current = m_paList->getNext(m_current);
		}
		else 
		{
			m_current = m_paList->front();
		}
		return m_current;
	} // operator++()


	template<class T >
	T* CipListIterator<T >::operator+=(int i_steps)
	{
		T* paElement = 0;
		for (int i_ = 0; i_ < i_steps; i_++)
		{
			if (!(paElement = operator++()))
			{
				break;
			}
		}
		return paElement;
	} // operator+=()


	template<class T >
	T* CipListIterator<T >::operator->(void)
	{
		return (m_current && !m_Deleted) ? m_current : 0;
	} // operator->()

	template<class T >
	void CipListIterator<T >::reset(void)
	{
		m_Deleted = false;
		m_current = 0;
	} // reset()


	template<class T >
	void CipListIterator<T >::reset(CipList<T >& i_ciplist)
	{
		m_Deleted = false;
		m_paList = &i_ciplist;
		m_current = 0;
	} // reset()


	template<class T >
	T* CipListIterator<T >::val(void)
	{
		return (m_current && !m_Deleted) ? m_current : 0;
	} // val()

	template<class T >
	bool CipListIterator<T >::isValid(void) const
	{
		return (m_current && !m_Deleted) ? true : false;
	} // isValid()

} // namespace ciplibrary

#endif // __CipListIterator__

/*********************************************************************
	End of cip list iterator header
*********************************************************************/
/* Actifsource ID=[4b422553-08ac-11e3-b902-17aaca85d2fd,a6d1b8c9-cedd-11de-80c2-87ac3b08f930,D+KW1qbVLwl+WMDRwqMIp8Li86E=] */
