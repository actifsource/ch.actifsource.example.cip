/*********************************************************************
	SYSTEM TemplateSystem
	IMPLEMENTATION Template_cpp
	cip process ProcessE file for PROCESS ProcessE
	Filename: PROC_ProcessE.cpp
	generated by CIP Tool(R)
	
	activated code options:
		C++ code
		use message interface
	            naming option: channel  prefix
	        all types in shell
	        enable mode inspection
	        'unsigned long' for delays
*********************************************************************/

#include "PROC_ProcessE.hpp"

namespace templateunit
{

	namespace clustera
	{
        
		/** constructors / destructors */
	        PROC_ProcessE::PROC_ProcessE(
			templateunit::cipshell::INTF_ActionMessagePort* i_amp,     
			ciplibrary::CipChainQueue<cipmachine::PROC_CipProcess >* i_chainQueue,     
			ciplibrary::CipAutoQueue<cipmachine::PROC_CipProcess >* i_autoQueue) :     
				INTF_ProcessE(),
				m_ActionMessagePort(i_amp),
				SELF(*this),
				ProcessE(this) ,
				m_chain(ciplibrary::CipChain<cipmachine::PROC_CipProcess >(this)),
				m_chainQueue(i_chainQueue),
				m_auto(ciplibrary::CipAuto<cipmachine::PROC_CipProcess >(this)),
				m_autoQueue(i_autoQueue)
		{
			setAuto();
		}// constructor
		
		/** initialize the pointers to interaction processes */
		void PROC_ProcessE::initInteraction(
			void* i_ProcessE,
			void* i_ProcessBB)
		{
			STATUS = static_cast<INTF_ProcessE* >(i_ProcessE);
			ProcessBB = static_cast<INTF_ProcessBB*>(i_ProcessBB);
		} // initInteraction()
		/** extension input functions */
		/**
		 * Trigger the process with inpulse CHAIN_.
		 */
		void PROC_ProcessE::CHAIN_(void)
	        {	      
			switch(STATE)
			{
				case IdleA:	
					/* [[727011fb-9b54-11ef-800e-630ffd8f1eac,Transition]] */
					printf("       TRANSITION '1 CHAIN_' ProcessE.normal: STATE IdleA -> IdleA  [727011fb-9b54-11ef-800e-630ffd8f1eac]\n");
					STATE = IdleA;
					setAuto();
					ProcessBB->BHV_InpulseA();     
				break;
			default:
				break;
			} 		
		} // CHAIN_()
	
		/**
		 * Trigger the process with inpulse AUTO_.
		 */
		void PROC_ProcessE::AUTO_(void)
		{	 	
			switch(STATE)
			{
				case IdleA:
					/* [[727011fd-9b54-11ef-800e-630ffd8f1eac,Transition]] */
					printf("       TRANSITION '3 AUTO_' ProcessE.normal: STATE IdleA -> IdleA  [727011fd-9b54-11ef-800e-630ffd8f1eac]\n");
					STATE = IdleA;
					clearAuto();
					setAuto();
					ProcessBB->BHV_InpulseA();     
				break;
			default:
				return;
			}  	
		} // AUTO_()
	        
	 	/** 
		 * Trigger the process with inpulse InpulseE.
		 */
		void PROC_ProcessE::BHV_InpulseE(void)
		{ 
			switch(STATE)
			{
				case IdleA:
					/* [[727011fc-9b54-11ef-800e-630ffd8f1eac,Transition]] */
					printf("       TRANSITION '2 InpulseE' ProcessE.normal: STATE IdleA -> IdleA  [727011fc-9b54-11ef-800e-630ffd8f1eac]\n");
					STATE = IdleA;
					setAuto();
					ProcessBB->BHV_InpulseA();     
				break;
			default:
				break;
			}     		
		} // BHV_InpulseE()
	
		/** Master and gate inspection access functions */
		/** 
		* return the current state of the process
		*/
		INTF_ProcessENames::E_State PROC_ProcessE::getState(void) const
		{
			return STATE;
		}
	        
		/** extension functions */
		void PROC_ProcessE::setChain(void)
		{
			m_chainQueue->setChain(&m_chain);
		}
	        
		void PROC_ProcessE::setAuto(void)
		{
			m_autoQueue->setAuto(&m_auto);
		}
	
		void PROC_ProcessE::clearAuto(void)
		{
			m_autoQueue->clearAuto(&m_auto);
		}
	        
	} // namespace clustera
} // namespace templateunit
/*********************************************************************
    End of cip process ProcessE for PROCESS ProcessE
*********************************************************************/
/* Actifsource ID=[1efc54ce-099f-11e3-b902-17aaca85d2fd,7270396a-9b54-11ef-800e-630ffd8f1eac,726fc458-9b54-11ef-800e-630ffd8f1eac,7270398d-9b54-11ef-800e-630ffd8f1eac,72703969-9b54-11ef-800e-630ffd8f1eac,72703968-9b54-11ef-800e-630ffd8f1eac,72701230-9b54-11ef-800e-630ffd8f1eac,7270120a-9b54-11ef-800e-630ffd8f1eac,rCHali0pBjQRtsk5PmE+vFNXlds=] */
