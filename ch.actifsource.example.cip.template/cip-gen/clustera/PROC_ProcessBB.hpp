/*********************************************************************
	SYSTEM TemplateSystem
	IMPLEMENTATION Template_cpp
	cip process ProcessBB header file for PROCESS ProcessBB
	Filename: PROC_ProcessBB.hpp
	generated by CIP Tool(R)
	
	activated code options:
		C++ code
		use message interface
	            naming option: channel  prefix
	        all types in shell
	        enable mode inspection
	        'unsigned long' for delays
*********************************************************************/

#if !defined(__PROC_ProcessBB__)
    #define __PROC_ProcessBB__

#include "INTF_ProcessBB.hpp"
#include "INTF_ActionMessagePort.hpp"
#include "CIPS_sTemplateUnit.hpp"
#include "INTF_Constant.hpp"
#include "CipTimer.hpp"
#include "CipTimerQueue.hpp"
#include "CipChain.hpp"
#include "CipChainQueue.hpp"
#include "INTF_ProcessBBNames.hpp"
#include "INTF_ProcessE.hpp"
#include "INTF_ProcessENames.hpp"
#include "INTF_ProcessFinalA.hpp"

namespace templateunit
{

	namespace clustera
	{
	
		/** 
		* class PROC_ProcessBB
		* process ProcessBB class
		*/
		class PROC_ProcessBB : 
			public INTF_ProcessBB, 
			public INTF_ProcessBBNames, 
			public templateunit::cipshell::INTF_Constant
		{
		public: 
            
		/** constructors / destructors */
		PROC_ProcessBB(
			templateunit::cipshell::INTF_ActionMessagePort* i_amp,
			ciplibrary::CipTimerQueue<cipmachine::PROC_CipProcess >* i_timerQueue,
			ciplibrary::CipChainQueue<cipmachine::PROC_CipProcess >* i_chainQueue);
            
		virtual ~PROC_ProcessBB(void){}
  
		/** initialize the pointers to interaction processes */
		void initInteraction(
			void* i_ProcessBB,
			void* i_ProcessE,
			void* i_ProcessFinalA);
		
		/** startup the entry function from the process */	
		void startup(void);

		/** INPORT EVENT_PORT */
		/** 
		* Trigger the process with message C1_msgB
		*/
		void C1_msgB(void);
            
		/** 
		* Trigger the process with message C1_msgA
		*/
		void C1_msgA(void);
            
		/** extension input functions */
		/** 
		* Trigger the process with inpulse CHAIN_.
		*/
		void CHAIN_(void);
            
		/** 
		* Trigger the process with inpulse TIMEUP_.
		*/
		void TIMEUP_(void);
            

		/** pulse cast input functions */
		/** 
		* Trigger the process with inpulse InpulseA.
		*/
		void BHV_InpulseA(void);
            
		/** 
		* Trigger the process with inpulse TestInpulseB.
		*/
		void BHV_TestInpulseB(void);
            
		/** inquiry function InquiryB */
		void InquiryB(void);
		
		/** inquiry function InquiryA */
		void InquiryA(void);
		
		

	private: 

		/** Trigger the process with state functions */
		void triggerStateAction(INTF_ProcessBBNames::E_StateAction stateAction, INTF_ProcessBBNames::E_State baseState);
		
		/** timer functions */
		void setTimer(unsigned long i_delay);
		void stopTimer(void);
            
		/** chain functions */
		void setChain(void);
            
		/** FUNCTION FunctionB */
		void FunctionB(void);

		/** FUNCTION FunctionA */
		void FunctionA(void);

		/** prohibitted default functions */
		PROC_ProcessBB(const PROC_ProcessBB&);
		PROC_ProcessBB& operator=(const PROC_ProcessBB&);

		/** process member data */
		templateunit::cipshell::INTF_ActionMessagePort* m_ActionMessagePort; // action hadler for cip machine
		PROC_ProcessBB& SELF; // own process instance cip macro for operations
		PROC_ProcessBB* ProcessBB; // own instance cip macro for inspections
		INTF_ProcessBB* STATUS; // status vector cip macro
		INTF_ProcessE* ProcessE; // process vector for pulse cast and inspections
		INTF_ProcessFinalA* ProcessFinalA; // process vector for pulse cast and inspections
		ciplibrary::CipTimer<cipmachine::PROC_CipProcess > m_timer; // process timer element
		ciplibrary::CipTimerQueue<cipmachine::PROC_CipProcess >* m_timerQueue; // timer queueu of cip machine
		ciplibrary::CipChain<cipmachine::PROC_CipProcess > m_chain; // process chain element
		ciplibrary::CipChainQueue<cipmachine::PROC_CipProcess >* m_chainQueue; // chain queue of cip machine

		/** local process variables */
		int VariableB;
		int VariableA;
		
		/** static gate truth tables */
		static const bool TRTAB_GateA[2];  // [ProcessE states] 
		static const bool TRTAB_GateB[2];  // [ProcessE states] 
		
		}; // class PROC_ProcessBB

	} // namespace clustera
} // namespace templateunit

#endif // __PROC_ProcessBB__

/*********************************************************************
    End of cip process ProcessBB header for PROCESS ProcessBB
*********************************************************************/
/* Actifsource ID=[45d0d2b1-099f-11e3-b902-17aaca85d2fd,7270396a-9b54-11ef-800e-630ffd8f1eac,726fc458-9b54-11ef-800e-630ffd8f1eac,7270398d-9b54-11ef-800e-630ffd8f1eac,72703969-9b54-11ef-800e-630ffd8f1eac,72703968-9b54-11ef-800e-630ffd8f1eac,72701230-9b54-11ef-800e-630ffd8f1eac,727011f8-9b54-11ef-800e-630ffd8f1eac,C+tcSX5jHuYzo5I9tcrUPBzvV3w=] */
