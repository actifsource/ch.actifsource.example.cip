/*********************************************************************
	SYSTEM TemplateSystem
	IMPLEMENTATION Template_cpp
	cip machine file for CIP MACHINE mTemplateUnit
	Filename: CIPM_mTemplateUnit.cpp
	generated by CIP Tool(R)
	
	activated code options:
		C++ code
		use message interface
	            naming option: channel  prefix
	        all types in shell
	        enable mode inspection
	        'unsigned long' for delays
*********************************************************************/

#include "CIPM_mTemplateUnit.hpp"
#include "PROC_ProcessBB.hpp"
#include "PROC_ProcessE.hpp"
#include "PROC_ProcessFinalA.hpp"


namespace templateunit
{
	namespace cipmachine
	{
        
		/** consructors / destructors */
		CIPM_mTemplateUnit::CIPM_mTemplateUnit(
			templateunit::cipshell::INTF_ActionMessagePort* i_amp) :
			m_ActionMessagePort(i_amp) 
		{
			TIME = 0;
			m_readQueue = new ciplibrary::CipReadQueue<ciplibrary::CipRead<cipmachine::LOCAL_QueueData, cipmachine::INTF_ReadNames::E_Reads, cipmachine::PROC_CipProcess >, ciplibrary::INTF_CipError<char > >(1);

			ProcessBB =
				new templateunit::clustera::PROC_ProcessBB(          
					m_ActionMessagePort,
					&m_timerQueue,
					&m_chainQueue);
			ProcessE =
				new templateunit::clustera::PROC_ProcessE(          
					m_ActionMessagePort,
					&m_chainQueue,
					&m_autoQueue);
			ProcessFinalA =
				new templateunit::clustera::PROC_ProcessFinalA(          
					m_ActionMessagePort,
					&m_chainQueue);
			ProcessBB->initInteraction(ProcessBB, ProcessE, ProcessFinalA);
			ProcessE->initInteraction(ProcessE, ProcessBB);
			ProcessFinalA->initInteraction(ProcessFinalA, ProcessE);
			ProcessBB->startup();
		} // constructor

		CIPM_mTemplateUnit::~CIPM_mTemplateUnit(void)
		{
        
			delete ProcessBB;	
			delete ProcessE;	
			delete ProcessFinalA;	
			delete m_readQueue;
		} // destructor

		/** event messages */
		/**
		* Triggers CIP Machine by input message msgA (channel EventA).
		*/
		void CIPM_mTemplateUnit::C1_msgA (void)
		{
			 ProcessBB->C1_msgA();
		} // C1_msgA()
		
		/**
		* Triggers CIP Machine by input message msgB (channel EventA).
		*/
		void CIPM_mTemplateUnit::C1_msgB (void)
		{
			 ProcessBB->C1_msgB();
		} // C1_msgB()
		
		/** extension functions */
		/** 
		* Triggers CIP Machine to increment time by one tick.
		*/
		void CIPM_mTemplateUnit::TICK_(void)
		{
			TIME += 1;
			m_timerQueue.TICK_();
		} // TICK_()

		/** 
		* Triggers CIP Machine to execute one pending internal activation.
		*  Search order: CHAIN_, TIMEUP_, READ_
		*/
		void CIPM_mTemplateUnit::STEP_(void)
		{
			if (m_chainQueue.hasCHAIN_())
			{
				m_chainQueue.CHAIN_();
			}
			else if (m_timerQueue.hasTIMEUP_())
			{
				m_timerQueue.TIMEUP_();
			}
			else if (m_autoQueue.hasAUTO_())
			{
				m_autoQueue.AUTO_();
			}
			else if (m_readQueue->hasREAD_())
			{
				m_readQueue->READ_();
			}
			else 
			{
				return;
			}
		} // STEP_()

		/** 
		* Triggers CIP Machine to execute one pending timeup activation.
		*/
		void CIPM_mTemplateUnit::TIMEUP_(void)
		{
			m_timerQueue.TIMEUP_();
		} // TIMEUP_()

		/** 
		* Triggers CIP Machine to execute one pending chain activation.
		*/
		void CIPM_mTemplateUnit::CHAIN_(void)
		{
			m_chainQueue.CHAIN_();
		} // CHAIN_()
  
		/** 
		* Trigger CIP Machine to execute one internally buffered message.
		*/
		void CIPM_mTemplateUnit::READ_(void)
		{
			if (m_readQueue->hasREAD_())
			{
				m_readQueue->READ_();
			}
			else 
			{
				m_autoQueue.AUTO_();
			}
		} // READ_()

		/** 
		* Trigger CIP Machine to execute one AUTO_
		*/
		void CIPM_mTemplateUnit::AUTO_(void)
		{
			m_autoQueue.AUTO_();
		} // AUTO_()

		/** 
		* Test if any local step activation is pending and return the result.
		* @return  if local step activation is pending.
		*/
		bool CIPM_mTemplateUnit::hasSTEP_(void)
		{
			return m_chainQueue.hasCHAIN_() || 
				m_timerQueue.hasTIMEUP_() || 
				m_autoQueue.hasAUTO_() || 
				m_readQueue->hasREAD_();
		} // hasSTEP_()
        
		/** 
		* Test if a chain activation is pending and return the result.
		* @return  if a chain activation is pending.
		*/
		bool CIPM_mTemplateUnit::hasCHAIN_(void)
		{
			return m_chainQueue.hasCHAIN_();
		} // hasCHAIN_()
        
		/** 
		* Test if a timeup activation is pending and return the result.
		* @return  if a timeup activation is pending.
		*/
		bool CIPM_mTemplateUnit::hasTIMEUP_(void)
		{
			return m_timerQueue.hasTIMEUP_();
		} // hasTIMEUP_()
        
		/** 
		* Test if a read activation is pending and return the result.
		* @return  if a read activation is pending.
		*/
		bool CIPM_mTemplateUnit::hasREAD_(void)
		{
			return m_readQueue->hasREAD_();
		} // hasREAD_()
        
		/** 
		* Test if an auto activation is pending and return the result.
		* @return  if a auto activation is pending.
		*/
		bool CIPM_mTemplateUnit::hasAUTO_(void)
		{
			return m_autoQueue.hasAUTO_();
		} // hasAUTO_()

	} // namespace cipmachine
} // namespace templateunit

/*********************************************************************
    End of cip machine for CIP MACHINE mTemplateUnit
*********************************************************************/
/* Actifsource ID=[77fe41ec-08ae-11e3-b902-17aaca85d2fd,7270396a-9b54-11ef-800e-630ffd8f1eac,726fc458-9b54-11ef-800e-630ffd8f1eac,7270398d-9b54-11ef-800e-630ffd8f1eac,72703969-9b54-11ef-800e-630ffd8f1eac,72703968-9b54-11ef-800e-630ffd8f1eac,6lWxPcX4umvecevAsnJ+W0CK5TA=] */
