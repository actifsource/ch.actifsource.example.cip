/*********************************************************************
	SYSTEM TemplateSystem
	IMPLEMENTATION Template_cpp
	cip machine header file for CIP MACHINE mTemplateUnit
	Filename: CIPM_mTemplateUnit.hpp
	generated by CIP Tool(R)
	
	activated code options:
		C++ code
		use message interface
	            naming option: channel  prefix
	        all types in shell
	        enable mode inspection
	        'unsigned long' for delays
*********************************************************************/

#if !defined(__CIPM_mTemplateUnit__)
    #define __CIPM_mTemplateUnit__

#include "INTF_Constant.hpp"
#include "INTF_ActionMessagePort.hpp"
#include "INTF_mTemplateUnit.hpp"
#include "INTF_ReadNames.hpp"
#include "LOCAL_QueueData.hpp"
#include "INTF_MachineProcess.hpp"
#include "CipTimerQueue.hpp"
#include "CipChainQueue.hpp"
#include "CipAutoQueue.hpp"
#include "CipReadQueue.hpp"

namespace templateunit
{
	namespace cipmachine
	{
        
		/** 
		* class CIPM_mTemplateUnit
		* cip machine for unit TemplateUnit
		*/
		class CIPM_mTemplateUnit : 
			public templateunit::cipshell::INTF_mTemplateUnit, 
			public templateunit::cipshell::INTF_Constant
		{
		public: 
            
			/** consructors / destructors */
				explicit
			CIPM_mTemplateUnit(
				templateunit::cipshell::INTF_ActionMessagePort* i_amp);
	
			CIPM_mTemplateUnit(void){}
	
			virtual ~CIPM_mTemplateUnit(void);
	
			/** event message interface */
			/** 
			* Triggers CIP Machine by input message doMachineStuff (channel EventA).
			*/
			virtual void C1_doMachineStuff(void);
	            
			/** 
			* Triggers CIP Machine by input message nextWorkload (channel EventA).
			*/
			virtual void C1_nextWorkload(void);
	            
			/** 
			* Triggers CIP Machine by input message powerFail (channel EventA).
			*/
			virtual void C1_powerFail(void);
	            
			/** 
			* Triggers CIP Machine by input message powerOff (channel EventA).
			*/
			virtual void C1_powerOff(void);
	            
			/** 
			* Triggers CIP Machine by input message powerOn (channel EventA).
			*/
			virtual void C1_powerOn(void);
	            
			/** extension interface */
			
			/** 
			* Triggers CIP Machine to increment time by one tick.
			*/
			virtual void TICK_(void);
	            
			/** 
			* Triggers CIP Machine to execute one pending internal activation.
			*  Search order: CHAIN_, TIMEUP_, READ_
			*/
			virtual void STEP_(void);
	            
			/** 
			* Triggers CIP Machine to execute one pending timeup activation.
			*/
			virtual void TIMEUP_(void);
	            
			/** 
			* Triggers CIP Machine to execute one pending chain activation.
			*/
			virtual void CHAIN_(void);
	            
			/** 
			* Trigger CIP Machine to execute one internally buffered message.
			*/
			virtual void READ_(void);
	            
			/** 
			* Trigger CIP Machine to execute one AUTO_
			*/
			virtual void AUTO_(void);
	
			/** 
			* Test if any local step activation is pending and return the result.
			* @return  if local step activation is pending.
			*/
			virtual bool hasSTEP_(void);
	            
			/** 
			* Test if a chain activation is pending and return the result.
			* @return  if a chain activation is pending.
			*/
			virtual bool hasCHAIN_(void);
	            
			/** 
			* Test if a timeup activation is pending and return the result.
			* @return  if a timeup activation is pending.
			*/
			virtual bool hasTIMEUP_(void);
	            
			/** 
			* Test if a read activation is pending and return the result.
			* @return  if a read activation is pending.
			*/
			virtual bool hasREAD_(void);
	            
			/** 
			* Test if an auto activation is pending and return the result.
			* @return  if a auto activation is pending.
			*/
			virtual bool hasAUTO_(void);
	
		private: 
	            
			/** prohibitted default functions */
	
			CIPM_mTemplateUnit(const CIPM_mTemplateUnit&);
			CIPM_mTemplateUnit& operator=(const CIPM_mTemplateUnit&);
	
	
			/** member variables */
	            
			/** user implemented output message handler */
			templateunit::cipshell::INTF_ActionMessagePort* m_ActionMessagePort;
	            
	
	            
			/** timer queue */
			ciplibrary::CipTimerQueue<cipmachine::PROC_CipProcess > m_timerQueue;
	            
			/** chain queue */
			ciplibrary::CipChainQueue<cipmachine::PROC_CipProcess > m_chainQueue;
	            
			/** auto queue */
			ciplibrary::CipAutoQueue<cipmachine::PROC_CipProcess > m_autoQueue;
	            
			/** read queue */
			ciplibrary::CipReadQueue<ciplibrary::CipRead<cipmachine::LOCAL_QueueData, cipmachine::INTF_ReadNames::E_Reads, cipmachine::PROC_CipProcess >, ciplibrary::INTF_CipError<char > >* m_readQueue;
	 
			/** Status vectors of cluster MachineCluster */
	
			/** Process MachineProcess */
			templateunit::machinecluster::INTF_MachineProcess* MachineProcess;
	            
		}; // class CIPM_mTemplateUnit

	} // namespace cipmachine
} // namespace templateunit

#endif // __CIPM_mTemplateUnit__

/*********************************************************************
    End of cip machine header for CIP MACHINE mTemplateUnit
*********************************************************************/

/* Actifsource ID=[65dba398-0beb-11e3-b115-a3f7f19b76fe,7270396a-9b54-11ef-800e-630ffd8f1eac,726fc458-9b54-11ef-800e-630ffd8f1eac,7270398d-9b54-11ef-800e-630ffd8f1eac,72703969-9b54-11ef-800e-630ffd8f1eac,72703968-9b54-11ef-800e-630ffd8f1eac,NiM9QAFwxRf91rhkZxER04oAb0Q=] */
