/*********************************************************************
  SYSTEM LampSystem
  IMPLEMENTATION LampImpl_c
  Error Header File for CIP MACHINE mLampUnit
  Filename: mainLampSystem_TestSuite_Console.c
  generated by CIP Tool(R)
  
  activated code options:
  	C code
  	use channel interface
  		naming option: use default prefix
  	use postfix
  		 LampUnit_HANS
  	enable mode inspection
  	'unsigned long' for delays
*********************************************************************/

/* Begin Protected Region [[include]] */

/* End Protected Region   [[include]] */
#include "mainLampSystem_TestSuite_Console.h"
#include "tLampUnit.h"
#include "animation/MessageHandler.h"
#include "animation/DataHandler.h"

#include <stdio.h>
#include <string.h>

#define VAR (*var_)

/** Enum to specify the trace mode. */
typedef enum ETraceMode
{
  eTrace_Disable,
  eTrace_Enable
} T_ETraceMode;

/** Enum variable to specify the animation mode. */
T_EAnimationMode g_eAnimationMode = eAnimationMode_Undefined;

/** Enum variable to specify the trace mode. */
T_ETraceMode g_eTraceMode = eTrace_Disable;

/** Enum for all event messages of this system. */
typedef enum EEventMessage
{
  eEventMessage_Quit = -1,
  eEventMessage_Tick = 0,
  eEventMessage_Step,
  eEventMessage_TimeUp,
  eEventMessage_Chain,
  eEventMessage_Read,
  eEventMessage_Auto,
  eEventMessage_ButtonEvents_Push,
  eEventMessage_ButtonEvents_Release,
  eEventMessageCount
} T_EEventMessage; 

/** Enum for all action messages of this system. */
typedef enum EActionMessage
{
  eActionContextError = 0,
  eActionFullBufferWarning,
  eActionBufferError,
  eActionPulseSelectionError,
  eActionMessageSelectionError,
  eActionInputError,
  eActionMessage_LampActions_Bright,
  eActionMessage_LampActions_Dark,
  eActionMessageCount
} T_EActionMessage; 

/** Enum for all test case. */
typedef enum ETestCase
{
  eTestCase_TestLamp
} T_ETestCase;

/* Checked output message */
const int checkedOutputMessage_TestLamp[eActionMessageCount] = {1, 1, 1, 1, 1, 1, 1, 1};

/** Typedef of all Event data. */
typedef union UEventData
{
  int tick;
} T_UEventData;




/** Recorded action message of this system. */
typedef struct SRecordedActionMessage
{
  T_EActionMessage actionMessage;
} T_RecordedActionMessage;

/** Maximum action messages which can be recorded per event message for automatic animation. */
enum {g_nMaxRecordedActionMessageCount = 100};

/** The number of recorded action messages. */
int g_nRecordedActionMessageCount = 0;

/** The number of expected action messages. */
int g_nExpectedActionMessageCount = 0;

/** An array which contains the recorded action messages. */
T_RecordedActionMessage g_eRecordedActionMessage[g_nMaxRecordedActionMessageCount];

/** System Tick. */
int s_nSystemTick = 0;

t_ConnectionContext s_connectionContext;

/* Active Test Case */
T_ETestCase activeTestCase;

/**
 * Returns the current animation connection
 */
t_ConnectionContext* Main_getConnectionContext(void) 
{
  return &s_connectionContext;
}

/**
 * Returns the current animation mode.
 */
T_EAnimationMode Main_getAnimationMode(void)
{
  return g_eAnimationMode;
}

/**
 * Checked output message
 */
char isCheckedOutputMessage(T_EActionMessage i_eActionMessage)
{
  switch (activeTestCase)
  {
     case eTestCase_TestLamp:
       return checkedOutputMessage_TestLamp[i_eActionMessage];
     default:
       return 0;
     break;
  }
  return 1;
}

/**
 *  Translates the given action message enum to string.
 *  @param i_eActionMessage The message type to translate.
 *  @return The translated action message or 0 if enum not found.
 */
const char* const translateActionMessage(T_EActionMessage i_eActionMessage)
{
  switch (i_eActionMessage)
  {
    case eActionMessage_LampActions_Bright:
      return "LampActions.Bright";
    break;
    case eActionMessage_LampActions_Dark:
      return "LampActions.Dark";
    break;
    case eActionMessageCount:
      return 0;
    break;
    default:
      return 0;
    break;
  }
  return 0;
}

/**
 *  Check if the Action message has equals data.
 *  @param i_eActionMessage The message type to translate.
 *  @return The action message is equals 1 or 0 if not.
 */
char equalsActionMessageData(T_RecordedActionMessage sActionMessage, T_RecordedActionMessage sRecordedActionMessage)
{
  switch (sRecordedActionMessage.actionMessage)
  {
    case eActionMessage_LampActions_Bright:
      return 1;
    break;
    case eActionMessage_LampActions_Dark:
      return 1;
    break;
    case eActionMessageCount:
      return 1;
    break;
    default:
      return 1;
    break;
  }
  return 1;
}

/**
 *  Check if the Action message has equals index.
 *  @param i_eActionMessage The message type to translate.
 *  @return The action message is equals 1 or 0 if not.
 */
char equalsActionMessageIndex(T_RecordedActionMessage sActionMessage, T_RecordedActionMessage sRecordedActionMessage)
{
  switch (sRecordedActionMessage.actionMessage)
  {
    case eActionMessage_LampActions_Bright:
      return 1;
    break;
    case eActionMessage_LampActions_Dark:
      return 1;
    break;
    case eActionMessageCount:
      return 1;
    break;
    default:
      return 1;
    break;
  }
  return 1;
}

/**
 *  Records the message action from the cip system.
 *  @param i_eActionMessage The message type to record.
 */
void recordMessageAction(T_RecordedActionMessage sRecordedActionMessage)
{
  if (g_nRecordedActionMessageCount>=g_nMaxRecordedActionMessageCount) {return;}
  g_eRecordedActionMessage[g_nRecordedActionMessageCount++] = sRecordedActionMessage;
}

/**
 *  Asserts the message action from the cip system.
 *  @param i_eActionMessage The action message type to compare.
 *  @param i_pcTestEventGuid The guid of the test event.
 *  @param i_pcActionMessageGuid The guid of the action message to compare.
 *  @return 1 if recoreded and expected message actions are equal. 0 if not.
 *  @warning Previously record message actions with recordMessageAction()
 */
int assertMessageAction(T_RecordedActionMessage sRecordedActionMessage, const char* const i_pcTestEventGuid, const char* const i_pcActionMessageGuid, const char* const i_testCaseName, int checkData)
{
  if (g_nExpectedActionMessageCount >= g_nRecordedActionMessageCount) 
  {
    if (g_eAnimationMode == eAnimationMode_Runner) {
       printf("6fa016b4-f5a7-11ee-8944-afc67c286a4c.asr: Failure\n");
       printf("TestCase: %s\n", i_testCaseName);
    }
    printf("    ASSERTION FAILED: %s\n",i_pcTestEventGuid);
    printf("    > Expected: ActionMessage #%i = %s %s\n", g_nExpectedActionMessageCount, translateActionMessage(sRecordedActionMessage.actionMessage), i_pcActionMessageGuid);
    printf("    > Recorded: -\n");
    return 0;
  }
  T_RecordedActionMessage sActionMessage = g_eRecordedActionMessage[g_nExpectedActionMessageCount++];
  if (sActionMessage.actionMessage != sRecordedActionMessage.actionMessage)
  {
    if (g_eAnimationMode == eAnimationMode_Runner) {
       printf("6fa016b4-f5a7-11ee-8944-afc67c286a4c.asr: Failure\n");
       printf("TestCase: %s\n", i_testCaseName);
    }
    printf("    ASSERTION FAILED: %s\n",i_pcTestEventGuid);
    printf("    > Expected: ActionMessage #%i = %s %s\n", g_nExpectedActionMessageCount, translateActionMessage(sRecordedActionMessage.actionMessage), i_pcActionMessageGuid);
    printf("    > Recorded: ActionMessage #%i = %s\n", g_nExpectedActionMessageCount, translateActionMessage(sActionMessage.actionMessage));
    return 0;
  }
  if (!equalsActionMessageIndex(sActionMessage, sRecordedActionMessage)) 
  {
    if (g_eAnimationMode == eAnimationMode_Runner) {
       printf("6fa016b4-f5a7-11ee-8944-afc67c286a4c.asr: Failure\n");
       printf("TestCase: %s\n", i_testCaseName);
    }
    printf("    ASSERTION FAILED: %s\n",i_pcTestEventGuid);
    printf("    > Expected: ActionMessage index not equals #%i = %s %s\n", g_nExpectedActionMessageCount, translateActionMessage(sRecordedActionMessage.actionMessage), i_pcActionMessageGuid);
    printf("    > Recorded: ActionMessage index not equals #%i = %s\n", g_nExpectedActionMessageCount, translateActionMessage(sActionMessage.actionMessage));
    return 0;
  }
  if (!checkData) return 1;
  if (!equalsActionMessageData(sActionMessage, sRecordedActionMessage)) 
  {
    if (g_eAnimationMode == eAnimationMode_Runner) {
       printf("6fa016b4-f5a7-11ee-8944-afc67c286a4c.asr: Failure\n");
       printf("TestCase: %s\n", i_testCaseName);
    }
    printf("    ASSERTION FAILED: %s\n",i_pcTestEventGuid);
    printf("    > Expected: ActionMessage data not equals #%i = %s %s\n", g_nExpectedActionMessageCount, translateActionMessage(sRecordedActionMessage.actionMessage), i_pcActionMessageGuid);
    printf("    > Recorded: ActionMessage data not equals #%i = %s\n", g_nExpectedActionMessageCount, translateActionMessage(sActionMessage.actionMessage));
    return 0;
  }
  return 1;
}

/**
 *  Asserts and resets the message action count variable.
 *  @param i_pcTestEventGuid The guid of the test event.
 *  @return 1 if recoreded and expected message action counts are equal. 0 if not.
 */
int assertMessageActionCount(const char* const i_pcTestEventGuid, const char* const i_testCaseName)
{
  int bEqualMessageActionCount = g_nExpectedActionMessageCount == g_nRecordedActionMessageCount;
  if (!bEqualMessageActionCount)
  {
    if (g_eAnimationMode == eAnimationMode_Runner) {
       printf("6fa016b4-f5a7-11ee-8944-afc67c286a4c.asr: Failure\n");
       printf("TestCase: %s\n", i_testCaseName);
    }
    printf("    ASSERTION FAILED: %s\n",i_pcTestEventGuid);
    printf("    > Expected: -\n");
    for (;g_nExpectedActionMessageCount<g_nRecordedActionMessageCount;++g_nExpectedActionMessageCount)
    {
      printf("    > Recorded: ActionMessage #%i = %s\n", g_nExpectedActionMessageCount+1,translateActionMessage(g_eRecordedActionMessage[g_nExpectedActionMessageCount].actionMessage));
    }
  }
  g_nRecordedActionMessageCount = 0;
  g_nExpectedActionMessageCount = 0;
  return bEqualMessageActionCount;
}

/**
 *  Function forward.
 */
void sendTickEvent(int i_nTickCount, int i_bAutoTimeup);
void sendStepEvent();
void sendChainEvent();
void sendAutoEvent();
void sendTimeupEvent();
void sendReadEvent();

/** 
 *  Sends the message event to the cip system.
 *  @param i_eEventMessage The message type to send.
 *  @param i_bAutoStep Automatically calls STEP_ if 1. Calls STEP_ for all pending events if code option enable_PENDING_Information set.
 *  @return 1 if ok. 0 if failed.
 */
int sendMessageEvent(T_EEventMessage i_eEventMessage, int i_bAutoStep, int i_bAutoTimeup, T_UEventData *eventData )
{
  switch (i_eEventMessage)
  {
    case eEventMessage_Tick:
      sendTickEvent(eventData->tick, i_bAutoTimeup);
    break;
    case eEventMessage_Step:
      sendStepEvent();
    break;
    case eEventMessage_TimeUp:
      sendTimeupEvent();
    break;
    case eEventMessage_Chain:
      sendChainEvent();
    break;
    case eEventMessage_Read:
      sendReadEvent();
    break;
    case eEventMessage_Auto:
      sendAutoEvent();
    break;
    case eEventMessage_ButtonEvents_Push:
      if (g_eTraceMode == eTrace_Enable) {printf(" EventMessage: ButtonEvents.Push  \n");}
      IN_LampUnit_HANS.ButtonEvents(C1_Push);
    break;
    case eEventMessage_ButtonEvents_Release:
      if (g_eTraceMode == eTrace_Enable) {printf(" EventMessage: ButtonEvents.Release  \n");}
      IN_LampUnit_HANS.ButtonEvents(C1_Release);
    break;
    default:
      return 0;
    break;
  }
  {
    if (g_eTraceMode == eTrace_Enable) {printf(" STEP_\n");}
    int maxStepCount = 0;
    for (maxStepCount=0;maxStepCount<i_bAutoStep;maxStepCount++) 
    {
      TRG_LampUnit_HANS.STEP_();
    }
  }
  return 1;
}

/** 
 *  Sends the tick event to the cip system.
 *  @param i_nTickCount The number of ticks.
 *  @param i_bAutoTimeup Calls TIMEUP_ after each tick if set.
 */
void sendTickEvent(int i_nTickCount, int i_bAutoTimeup)
{
  int nTickCount;
  int nAutoCount;
  if (g_eTraceMode == eTrace_Enable) {printf(" START TICK_ #%i\n",s_nSystemTick);}  
  if (g_eAnimationMode == eAnimationMode_Visual) {
    char message[100];
    JsonUtl_initStringBuffer(message);
    JsonUtl_appendString(message, "START TICK_ ");
    JsonUtl_appendInteger(message, s_nSystemTick);
    MessageHandler_sendTestbenchLogResponse(&s_connectionContext, message);
  }
  for (nTickCount=0;nTickCount<i_nTickCount;++nTickCount)
  {
    s_nSystemTick++;
    TRG_LampUnit_HANS.TICK_(); 
    for(nAutoCount=0;nAutoCount<i_bAutoTimeup;nAutoCount++)  
    {
      TRG_LampUnit_HANS.TIMEUP_();
    }
  }
  if (g_eAnimationMode == eAnimationMode_Visual) {
    char message[100];
    JsonUtl_initStringBuffer(message);
    JsonUtl_appendString(message, "END TICK_ ");
    JsonUtl_appendInteger(message, s_nSystemTick);
    MessageHandler_sendTestbenchLogResponse(&s_connectionContext, message);
  }
  if (g_eTraceMode == eTrace_Enable) {printf(" END TICK_ #%i\n",s_nSystemTick);}
}

/** 
 *  Sends the step event to the cip system.
 */
void sendStepEvent()
{
  if (g_eTraceMode == eTrace_Enable) {printf(" STEP_\n");}
  TRG_LampUnit_HANS.STEP_();
}

/** 
 *  Sends the chain event to the cip system.
 */
void sendChainEvent()
{
  if (g_eTraceMode == eTrace_Enable) {printf(" CHAIN_\n");}
  TRG_LampUnit_HANS.CHAIN_(); 
}

/** 
 *  Sends the timeup event to the cip system.
 */
void sendTimeupEvent()
{
  if (g_eTraceMode == eTrace_Enable) {printf(" TIMEUP_\n");}
  TRG_LampUnit_HANS.TIMEUP_(); 
}

/** 
 *  Sends the read event to the cip system.
 */
void sendReadEvent()
{
  if (g_eTraceMode == eTrace_Enable) {printf(" READ_\n");}
  TRG_LampUnit_HANS.READ_(); 
}

/** 
 *  Sends the auto event to the cip system.
 */
void sendAutoEvent()
{
  if (g_eTraceMode == eTrace_Enable) {printf(" AUTO_\n");}
  TRG_LampUnit_HANS.AUTO_(); 
}

/** 
 *  LampActions.Bright action message callback (Action Initiation).
 */
void AI_LampUnit_HANS_C2_Bright()
{
  if (g_eTraceMode == eTrace_Enable) {printf("   ActionMessage: LampActions.Bright \n\n");}
  if (g_eAnimationMode == eAnimationMode_Regressive || g_eAnimationMode == eAnimationMode_Runner) {
    T_RecordedActionMessage sRecorded;
    sRecorded.actionMessage = eActionMessage_LampActions_Bright;
    if (!isCheckedOutputMessage(sRecorded.actionMessage)) return;
    recordMessageAction(sRecorded);
  }
  if (g_eAnimationMode == eAnimationMode_Visual) {
    MessageHandler_sendTestbenchAction(&s_connectionContext, eActionMessage_LampActions_Bright, NULL, NULL);
  }
}

/** 
 *  LampActions.Dark action message callback (Action Initiation).
 */
void AI_LampUnit_HANS_C2_Dark()
{
  if (g_eTraceMode == eTrace_Enable) {printf("   ActionMessage: LampActions.Dark \n\n");}
  if (g_eAnimationMode == eAnimationMode_Regressive || g_eAnimationMode == eAnimationMode_Runner) {
    T_RecordedActionMessage sRecorded;
    sRecorded.actionMessage = eActionMessage_LampActions_Dark;
    if (!isCheckedOutputMessage(sRecorded.actionMessage)) return;
    recordMessageAction(sRecorded);
  }
  if (g_eAnimationMode == eAnimationMode_Visual) {
    MessageHandler_sendTestbenchAction(&s_connectionContext, eActionMessage_LampActions_Dark, NULL, NULL);
  }
}

/**
* AI_LampUnit_HANSLampActions
*/
void AI_LampUnit_HANSLampActions (enum eMSG_LampActions_HANS name_)
{
  switch(name_)
  {
  case C2_Bright:
      AI_LampUnit_HANS_C2_Bright();
    break;
  case C2_Dark:
      AI_LampUnit_HANS_C2_Dark();
    break;
  default: 
    break;
  }
}


/** 
 *  Shell Initialization Function. 
 */
void iCHAN_LampUnit_HANS()
{
  OUT_LampUnit_HANS.LampActions = AI_LampUnit_HANSLampActions;
  /* Input error */
}

/** 
 *  Pointer to User defined Trace dump Function. 
 */
void TRACE_LampUnit_HANS_DUMP (struct tTRACE_DUMP_LampUnit_HANS *element)
{
  if (g_eAnimationMode == eAnimationMode_Visual)
  {
    t_ConnectionData *connectionData = MessageHandler_getConnectionData(&s_connectionContext);
    if (connectionData->isBinded) 
    {
      connectionData->sequenceNumber = 0;
      MessageHandler_sendElement(&s_connectionContext, element->processId, element->multiplicityIndex, element->modeState, 0);
    }
  }
}

/** 
 *  Pointer to User defined Trace state change Function. 
 */
void TRACE_LampUnit_HANS_CHANGE (unsigned char elementCount, struct tTRACE_CHANGE_LampUnit_HANS elements[])
{
  if (g_eAnimationMode == eAnimationMode_Visual)
  {
    int index = 0;
    t_ConnectionData *connectionData = MessageHandler_getConnectionData(&s_connectionContext);  
    if (connectionData->isBinded) 
    {
      connectionData->sequenceNumber++;
      for(index = 0; index < elementCount; index++) {
        MessageHandler_sendElement(&s_connectionContext, elements[index].processId, elements[index].multiplicityIndex, elements[index].changeId, connectionData->sequenceNumber);
      }
    }
  }
}

/** 
 *  Trace initialization Function. 
 */
void iTRACE_LampUnit_HANS(void)
{
 TRACE_LampUnit_HANS.DUMP_ = TRACE_LampUnit_HANS_DUMP;
 TRACE_LampUnit_HANS.CHANGE_ = TRACE_LampUnit_HANS_CHANGE;
}

/** Forward TestCase TestLamp */
int testCase_TestLamp(int mainTestCase);

/** 
 *  TestCase TestLamp
 *  mainTestCase 1 if main test case, 0 if sub test case.
 *  @return 1 if test case ok. 0 if test case failed.
 */
int testCase_TestLamp(int mainTestCase)
{
  T_UEventData data;
  T_RecordedActionMessage sRecorded;
  
  if (mainTestCase) 
  {
    printf(">>> TestCase TestLamp [6fa016b8-f5a7-11ee-8944-afc67c286a4c]\n");
    s_nSystemTick = 0;
    g_nRecordedActionMessageCount = 0;
    g_nExpectedActionMessageCount = 0;
    if (!fINIT_LampUnit_HANS()) 
    {
      printf("\nInitialization failed\n"); 
      return 0;
    }
  }
  
  activeTestCase = eTestCase_TestLamp;
  sendMessageEvent(eEventMessage_ButtonEvents_Push, 50, 50, &data);
  sRecorded.actionMessage = eActionMessage_LampActions_Bright;
  if (!assertMessageAction(sRecorded,"TestEvent ButtonEvents.Push [6fa016b7-f5a7-11ee-8944-afc67c286a4c]","[6fa016b5-f5a7-11ee-8944-afc67c286a4c]", "TestLamp" ,0)) {return 0;}
  if (!assertMessageActionCount("TestEvent ButtonEvents.Push [6fa016b7-f5a7-11ee-8944-afc67c286a4c]", "TestLamp")) {return 0;}
  

  return 1;
}

/** 
 *  Write string to file.
 */
void printToFile(FILE *fp, const char* s) 
{
  if (fp == NULL) return;
  fprintf(fp, s);
}

/** 
 *  Regressive animation, controlled by test cases. 
 *  @return The number of failed test cases.
 */
int regressiveAnimation()
{
  printf("TESTING: CipTestSuite LampSystemTestSuite [6fa016b4-f5a7-11ee-8944-afc67c286a4c]\n\n"); 
  g_eAnimationMode = eAnimationMode_Regressive;
  int nSuceededTestCases = 0;
  int nFailedTestCases = 0;
  g_eTraceMode = eTrace_Disable;
  if (testCase_TestLamp(1)) {++nSuceededTestCases;} else {++nFailedTestCases;}
  printf("\n> SUMMARY: %i Test Case(s) Executed.\n",nSuceededTestCases+nFailedTestCases); 
  if (nFailedTestCases) {printf("> WARNING: %i Test Case(s) Failed.\n",nFailedTestCases);} 
  return nFailedTestCases;
}

/** 
 *  C/C++ Unit gtest, controlled by test cases. 
 *  @return The number of failed test cases.
 */
int runnerAnimation(FILE *fp)
{
  int nSuceededTestCases = 0;
  int nFailedTestCases = 0;
  g_eAnimationMode = eAnimationMode_Runner;
	  
  printf("[==========] Running 1 test from 1 test case.\n");
  printf("[----------] Global test environment set-up.\n");
  printf("[----------] 1 test from LampSystemTestSuite\n");
   
  printToFile(fp, "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n");
  printToFile(fp, "<testsuite name=\"LampSystemTestSuite\">\n");
      	  
  /* TestLamp */
  g_eTraceMode = eTrace_Disable;
  printf("[ RUN      ] LampSystemTestSuite.TestLamp\n");
  if (testCase_TestLamp(1)) {
  	++nSuceededTestCases;
  	printf("[       OK ] LampSystemTestSuite.TestLamp (%i ms)\n",s_nSystemTick);
  	printToFile(fp, "    <testcase name=\"TestLamp\" status=\"run\" />\n");
  } else {
  	++nFailedTestCases;
	printf("[  FAILED  ] LampSystemTestSuite.TestLamp (%i ms)\n",s_nSystemTick);
	printToFile(fp, "    <testcase name=\"TestLamp\" status=\"run\">\n");
	printToFile(fp, "        <failure><![CDATA[Failure testcase: 6fa016b8-f5a7-11ee-8944-afc67c286a4c]]></failure>\n");
	printToFile(fp, "    </testcase>\n");
  }
	
  printToFile(fp, "</testsuite>");
  
  printf("[----------] 1 test from LampSystemTestSuite (0 ms total)\n");
  printf("\n> SUMMARY: %i Test Case(s) Executed.\n",nSuceededTestCases+nFailedTestCases); 
  if (nFailedTestCases) {
  	printf("> WARNING: %i Test Case(s) Failed.\n",nFailedTestCases);
  }
  printf("[----------] Global test environment tear-down\n");
  printf("[==========] 1 test from 1 test case ran. (0 ms total)\n");
  return nFailedTestCases;
}

/** 
 *  Manual animation, controlled by keyboard input. 
 *  @return 0 if exited normally. 1 otherwise.
 */
int manualAnimation()
{
  T_UEventData data;
  g_eAnimationMode = eAnimationMode_Manual;
  g_eTraceMode = eTrace_Enable;
  
  if (!fINIT_LampUnit_HANS()) 
  {
    printf("\nInitialization failed\n");
    return 1;
  }
  
  while (1) 
  {
    printf("------------------------------------\n");
    printf("Enter -1 (Quit)\n");
    printf("Enter 0 (Tick  & TimeUp)\n");
    printf("Enter 1 (Step)\n");
    printf("Enter 2 (TimeUp)\n");
    printf("Enter 3 (Chain)\n");
    printf("Enter 4 (Read)\n");
    printf("Enter 5 (Auto)\n");
    printf("Enter  %i (ButtonEvents: Push)\n",eEventMessage_ButtonEvents_Push);
    printf("Enter  %i (ButtonEvents: Release)\n",eEventMessage_ButtonEvents_Release);
    printf("------------------------------------\n");

    T_EEventMessage eEventMessage;
    scanf("%i", (int*)&eEventMessage);
    if (eEventMessage == eEventMessage_Quit) {break;}
    else if (eEventMessage == eEventMessage_Tick) {
        data.tick = 1;
        sendMessageEvent(eEventMessage_Tick, 50, 50, &data);
    }
    else if (!sendMessageEvent(eEventMessage, 50, 50, &data)) {printf("\n Invalid Input: %i\n\n",eEventMessage);}
  }
  return 0;
}

/**************************************************
 * Visaul Animation
 **************************************************/

/** 
 *  Get EventData from the channel message.
 *  @return true or false.
 */
static int getEventData(t_TokensContext* tokenContext, T_EEventMessage eventMessage, T_UEventData *data)
{
  switch(eventMessage) 
  {
  case eEventMessage_Tick:
    if (MessageHandler_hasValue(tokenContext))
    {
      jsmntok_t token;
      int integer;
      if (!JsonUtl_getNextToken(tokenContext, &token)) return 0;
      if (!JsonUtl_getTokenInteger(token, tokenContext, &integer)) return 0;
      data->tick = integer;
    } 
    else 
    {
      data->tick = 1;
    }
    return 1;
  case eEventMessage_Step:
    return 1;	
  case eEventMessage_TimeUp:
    return 1;	
  case eEventMessage_Chain:
    return 1;
  case eEventMessage_Read:
    return 1;	
  case eEventMessage_Auto:
    return 1;
  case eEventMessage_ButtonEvents_Push:
    return 1;
      break;
  case eEventMessage_ButtonEvents_Release:
    return 1;
      break;
    default:
      break;
  }
  return 0;
}


/** 
 *  get the EventMessage by event id.
 *  @return true or false.
 */
static int getEventMessage(t_JsonId *eventId, T_EEventMessage *eventMessage)
{
  int subId = 0;
  if (eventId->idSize != 1) return 0;
  subId = eventId->id[0];
  if (eEventMessageCount <= subId || subId < 0) return 0;
  *eventMessage = (T_EEventMessage)subId;
  return 1;
}

/**
 *  Regressive animation, controlled by test cases.
 *  @return The number of failed test cases.
 */
int handleVisualAnimationJsonMessage(t_TokensContext* tokenContext, t_ConnectionContext* connection) 
{
  jsmntok_t token;
  t_ConnectionData *connectionData = MessageHandler_getConnectionData(connection);

  if (!JsonUtl_getNextToken(tokenContext, &token)) return False;
  if (!JsonUtl_isObject(token)) return False;
  if (!JsonUtl_getNextToken(tokenContext, &token)) return False;

  /* BIND */
  if (JsonUtl_equalsTokenString(token, tokenContext, TOKEN_BIND))
  {
    t_JsonId modulId;
    if (!MessageHandler_getBindId(tokenContext, &modulId)) return 0;
    connectionData->isBinded = 1;
    connectionData->bindId = modulId;
    MessageHandler_sendStartTypeHistory(connection, &modulId);
    MessageHandler_sendStartTypeSnapshot(connection, &modulId);
    fDUMP_LampUnit_HANS();
    MessageHandler_sendStartTypeUpdate(connection, &modulId);
    return 1;
  }

  /* UNBIND */
  if (JsonUtl_equalsTokenString(token, tokenContext, TOKEN_UNBIND))
  {
    t_JsonId jsonId;
    if (!MessageHandler_getBindId(tokenContext, &jsonId)) return 0;
    t_ConnectionData *connectionData = MessageHandler_getConnectionData(connection);
    connectionData->isBinded = 0;
    connectionData->bindId = jsonId;
    return 1;
  }

  /* TOKEN_EXPLORER_TREE */
  if (JsonUtl_equalsTokenString(token, tokenContext, TOKEN_EXPLORER_TREE))
  { 
    return 1;
  }

  /* TOKEN_ERROR */
  if (JsonUtl_equalsTokenString(token, tokenContext, TOKEN_ERROR))
  {
    if (!fINIT_LampUnit_HANS())
    {
      printf("Reset Cip-System \n");
    }
    return 1;
  }
  
  /* TOKEN_TEST_BENCH_STATE */
  if (JsonUtl_equalsTokenString(token, tokenContext, TOKEN_TEST_BENCH_STATE))
  {
    if (!MessageHandler_isResetRequest(tokenContext)) return 0;
    if (!fINIT_LampUnit_HANS())
    {
      MessageHandler_sendErrorResponse(&s_connectionContext, "Cip Initialization failed.");
      return 0;
    }
    if (connectionData->isBinded)
    {
      MessageHandler_sendStartTypeHistory(connection, &connectionData->bindId);
      MessageHandler_sendStartTypeSnapshot(connection, &connectionData->bindId);
      fDUMP_LampUnit_HANS();
      MessageHandler_sendStartTypeUpdate(connection, &connectionData->bindId);
    }
    printf("Reset Cip-System \n");
    MessageHandler_sendCompleteResponse(connection);
    return 1;
  }

  /* TOKEN_TEST_BENCH_EVENT */
  if (JsonUtl_equalsTokenString(token, tokenContext, TOKEN_TEST_BENCH_EVENT))
  {
    t_JsonId eventId;
    T_EEventMessage eventMessage;
    T_UEventData eventData;
 
    if (!MessageHandler_getTestBenchEventId(tokenContext, &eventId)) return 0;
    if (!getEventMessage(&eventId, &eventMessage))
    {
       MessageHandler_sendErrorResponse(&s_connectionContext, "Error: Event message id is invalide.");
       return 0;
    }

    if (!getEventData(tokenContext, eventMessage, &eventData)) 
    {
      MessageHandler_sendErrorResponse(&s_connectionContext, "Error: Pars event data.");
      return 0;
    }
    
    if (!sendMessageEvent(eventMessage, 50, 50, &eventData))
    {
      MessageHandler_sendErrorResponse(&s_connectionContext, "Error: Send message event.");
      return 0;
    }
    MessageHandler_sendCompleteResponse(connection);
    return 1;
  }
  return 0;
}

/**
 *  Regressive animation, controlled by test cases.
 *  @return The number of failed test cases.
 */
int visualAnimation()
{
  int failed = 0;// False
  char jsonMessage[500];
  char message[500];
  t_TokensContext tokenContext;
  t_ConnectionData connectionData;
  connectionData.isBinded = 0;
  connectionData.sequenceNumber = 0;
	  
  s_connectionContext.userData = &connectionData;
  g_eAnimationMode = eAnimationMode_Visual;

  printf("Start animation server port: %d ...", SERVER_PORT);
  if (!AnimationSocket_Start()) 
  {
    printf("Error \n");
    return 1;
  }
  printf(" Started\n");
  
  while (!failed) 
  {

    if (!s_connectionContext.connected) 
    {
      if (!AnimationSocket_AcceptClient(&s_connectionContext)) 
      {
        printf("Accept client fail. \n");
        failed = 1;
        break;
      }
      
      MessageHandler_sendLogInfoResponse(&s_connectionContext, "Client is connected to animation server.");

      if (!fINIT_LampUnit_HANS())
      {
        MessageHandler_sendErrorResponse(&s_connectionContext, "Cip Initialization failed.");
        AnimationSocket_Close(&s_connectionContext);
        failed = 1;
        break;
      }
    }

    if (!JsonUtl_readMessage(&s_connectionContext, jsonMessage)) {
      MessageHandler_sendErrorResponse(&s_connectionContext, "Read message failed.");
      AnimationSocket_Close(&s_connectionContext);
      continue;
    }

    if (!JsonUtl_parsMessage(jsonMessage, &tokenContext)) 
    {
      JsonUtl_initStringBuffer(message);
      JsonUtl_appendString(message, "Pars json message failed: ");
      JsonUtl_appendString(message, jsonMessage);
      MessageHandler_sendErrorResponse(&s_connectionContext, message);
      failed = 1;
      break;
    }

    if (!handleVisualAnimationJsonMessage(&tokenContext, &s_connectionContext)) {
      MessageHandler_sendErrorResponse(&s_connectionContext, "Handle json message failed.");
    }
  }

  if (!AnimationSocket_Close(&s_connectionContext)) {
    MessageHandler_sendErrorResponse(&s_connectionContext, "Close socket failed.");
    failed = 1;
  }
  
  printf("Stop animation server port: %d ...", SERVER_PORT);
  return failed;
}

/** 
 *  Displays an info text for this program.
 *  @param i_pcProgramName The name of the program file.
 */
void displayInfoText(char* i_pcProgramName)
{
  printf("Usage: %s [option]\n",i_pcProgramName);
  printf(" [option]\n");
  printf(" - manual:     Manual animation, controlled by keyboard input.\n");
  printf(" - regressive: Regressive animation, controlled by test cases.\n");
  printf(" - runner [optional filename]: C/C++ Unit gtest.\n");
  printf(" - animation: Visual browser animation.\n");
}

/**
 *  Main program for animation.
 *  @param @argc The number of arguments passed to the program.
 *  @param @argv The arguments passed to the program.
 *  @return 0 if exited normally. 1 otherwise.
 */
int main(int argc, char *argv[]) 
{
  int ret;
  if (argc == 1) 
  {
    displayInfoText(argv[0]);
    return 1;
  }

  if (strcmp(argv[1],"manual")==0) 
  {
    ret = manualAnimation()?1:0;
    return ret;
  }
  if (strcmp(argv[1],"regressive")==0) 
  {
    ret = regressiveAnimation()?1:0;
    return ret;
  }
  if (strcmp(argv[1],"runner")==0) 
  {
    FILE *fp = NULL;
    if (argc >= 2) {
        fp = fopen(argv[2], "w+");
    }
    ret = runnerAnimation(fp)?1:0;
    if (fp != NULL) {
        fclose(fp);
    }
    return ret;
  }
  if (strcmp(argv[1],"animation")==0)
  {
	ret = visualAnimation()?1:0;
	return ret;
  }
  displayInfoText(argv[0]);
  return 1;
}

/* Actifsource ID=[bc0af8c6-407d-11e2-9941-ff65f3a86106,6fa016b4-f5a7-11ee-8944-afc67c286a4c,YzyZXyERjYxlHtqln9cBTCxjq78=] */
