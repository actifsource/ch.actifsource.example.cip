/*********************************************************************
	SYSTEM CIPLIBRARY
	cip ring buffer header file 
	Filename: RingBuffer.hpp
	generated by CIP Tool(R)
	activated code options:
		C++ code
*********************************************************************/

#if !defined(__RingBuffer__)
	#define __RingBuffer__

#include "INTF_CipError.hpp"

namespace ciplibrary
{
	
	/** 
	 * class RingBuffer
	 * Implements a ring buffer with a predefined number of buckets of a given type.
	 * @template R Type of the buckets (CipRead)
	 * @template C Template parameter for template class INTF_CipError
	 */
	template<class R, class E >
	class RingBuffer
	{
	public: 
		
		/** 
		 * Consructor
		 * The number of buckets in the ring buffer is statically defined in the CIP specification
		 * @param i_size the number of buckets in the ring buffer predefined in the CIP specification.
		 * @param i_error pointer to cip error object,  needed for buffer warning notification.
		 */
		explicit RingBuffer(const unsigned int i_size, E* i_error);
		
		/** 
		 * Destructor
		 * Deletes the buckets of the ring buffer
		 */
		virtual ~RingBuffer(void);
		
		/** 
		 * Finds the next free element of the ring buffer
		 * @return Pointer to the next free element or 0 if the buffer is full.
		 */
		R* getNext(void);
		
		/** 
		 * Gets the head element of the ring buffer
		 * @return Pointer to the head element or 0 if the buffer is empty.
		 */
		R* getHead(void);
		
		/** 
		 * Gets the head element of the ring buffer and moves the head to the next element.
		 * @return Pointer to the head element or 0 if the buffer is empty.
		 */
		R* popHead(void);
		
		/** 
		 * Tests whether the ring buffer is empty
		 * @return true if the buffer is empty; false otherwise.
		 */
		bool empty(void) const;

	private: 
		
		/** prohibitted default functions */
		RingBuffer(const RingBuffer&);
		RingBuffer& operator=(const RingBuffer&);

		
		/** member variables */
		const unsigned int m_size;
		E* m_error;
		R* m_buffer;
		R* m_head;
		R* m_next;

	}; // class RingBuffer

/*********************************************************************
*********************************************************************/


	template<class R, class E >
	RingBuffer<R, E >::RingBuffer(const unsigned int i_size, E* i_error) : 
		m_size(i_size), 
		m_error(i_error)
	{
		m_buffer = new R[m_size];
		m_head = 0;
		m_next = &m_buffer[0];
	}

	template<class R, class E >
	RingBuffer<R, E >::~RingBuffer(void)
	{
		delete []m_buffer;
	}

	template<class R, class E >
	R* RingBuffer<R, E >::getNext(void)
	{
		// buffer is full
		if (m_head == m_next)
		{
			return 0;
		}
		
		// buffer is empty
		if (m_head == 0)
		{
			m_head = m_next;
		}
		
		// get free bucket
		R* l_current = m_next;
		
		// move next pointer
		if (l_current == &m_buffer[m_size - 1])
		{
			m_next = &m_buffer[0];
		}
		else 
		{
			++m_next;
		}
		
		// buffer has become full
		if (m_error && (m_next == m_head))
		{
			m_error->call_BufferWarning();
		}

		return l_current;
	} // getNext()

	template<class R, class E >
	R* RingBuffer<R, E >::getHead(void)
	{
		return m_head;
	} // getHead()

	template<class R, class E >
	R* RingBuffer<R, E >::popHead(void)
	{
		// buffer is empty
		if (m_head == 0)
		{
			return 0;
		}
		
		// move head pointer
		R* l_current = m_head;
		if (m_head == &m_buffer[m_size - 1])
		{
			m_head = &m_buffer[0];
		}
		else 
		{
			++m_head;
		}
		
		// buffer becomes empty
		if (m_head == m_next)
		{
			m_head = 0;
		}
		return l_current;
	} // getNext()

	template<class R, class E >
	bool RingBuffer<R, E >::empty(void) const
	{
		return m_head == 0;
	} // empty()

} // namespace ciplibrary

#endif // __RingBuffer__

/*********************************************************************
	End of cip ring buffer header
*********************************************************************/
/* Actifsource ID=[d20a1fed-08ad-11e3-b902-17aaca85d2fd,a6d1b8c9-cedd-11de-80c2-87ac3b08f930,awgyEBIhXvaaQ6MMvUiCN1l8fzo=] */
