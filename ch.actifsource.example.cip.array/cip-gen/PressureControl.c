/*******************************************************************
        SYSTEM ChairArray
        Module for PROCESS PressureControl
        Filename: PressureControl.c
        generated by CIP Tool(R)

        activated code options:
        	C code
        	use channel interface
        		naming option: use default prefix
        	'unsigned long' for delays
*********************************************************************/

/* Include Files */

#include "mChairUnit.h"

/* Process Macro Definitions */

#define ID (*id_)
#define IN (*in_)
#define SELF (*self_)
#define STATUS (pStatus_PressureControl->read_access_)
#define TIME time_

/* Process Enumerations */

enum eMODES_PressureControl
	{standby = 1, control = 2, observe = 3};

enum eSTATES_PressureControl
	{equals = 1, evacuate, filling};

enum eINPULS_PressureControl
	{IP_limitPressure = 3};
	

/* External Declarations */

extern unsigned long time_;
extern struct tCHNOUT_mChairUnit CHNOUT_mChairUnit;
extern struct tPRACS_Pressure Pressure;
extern union tSTATUS_PassengersControl status_PassengersControl;
extern union tSTATUS_Pressure status_Pressure;
int fPULSE_Proxy (enum eOUTPLS_ name_,
  struct tID_Proxy *procid_);

/* Global Declarations */

union tSTATUS_PressureControl status_PressureControl;
const union tSTATUS_PressureControl *pStatus_PressureControl = &status_PressureControl;
static struct tPRSTAT_PressureControl *self_;
static struct tID_PressureControl currentid_;
static const struct tID_PressureControl *id_ = &currentid_;
const int MODTAB_PressureControl[3][3] =       /* [Pressure states][PassengersControl states] */
	{{standby, standby, control},
	{standby, standby, control},
	{observe, observe, control}};


/* Function Prototypes */

int fPULSE_PressureControl (enum eOUTPLS_ name_,
   union tOUTPLS_ChairCluster *data_,
   struct tID_PressureControl *procid_);
void fINIT_PressureControl (void);

/* Multiple Cast Functions */

static void fCAST_Proxy(enum eOUTPLS_ name_,
   struct tID_PressureControl *txid_)
{
	struct tID_Proxy ID_Proxy;
	ID_Proxy.cushionIndex = txid_->cushionIndex;
	switch(name_)
	{	
	case O7_evac:
	case O7_fill:
	case O7_stop:
		fPULSE_Proxy(name_, &ID_Proxy);
		break;
	default: 
		break;
	}
}	
/* Input Channel Functions */

int fPULSE_PressureControl (enum eOUTPLS_ name_,
   union tOUTPLS_ChairCluster *data_,
   struct tID_PressureControl *procid_)
{
	struct tID_PressureControl ID_PressureControl;
	currentid_ = *procid_;
	ID_PressureControl = *procid_;
	self_ = &status_PressureControl.write_access_[currentid_.cushionIndex];
	switch(name_)
	{
		/* INPULSE limitPressure */
	case O2_limitPressure:		/* PULSE CAST from PROCESS Pressure */
		{	
			struct tCIPREC_tPressure IN = &data_->OUTPLS_Pressure.data_._tPressure;
			switch(MODTAB_PressureControl[status_Pressure.read_access_[currentid_.cushionIndex].STATE - 1]
			[status_PassengersControl.read_access_[currentid_.cushionIndex].STATE - 1])
			{
			case control:
				switch(status_PressureControl.read_access_[currentid_.cushionIndex].STATE)
				{
				case equals:
					if (SELF.observedPressure < IN.value)	/***  CONDITION isHigh  ***/
					{
						status_PressureControl.write_access_[currentid_.cushionIndex].STATE = evacuate;
						fCAST_Proxy (O7_evac, &ID_PressureControl);
					}
					else if (SELF.observedPressure > IN.value)	/***  CONDITION isLow  ***/
					{
						status_PressureControl.write_access_[currentid_.cushionIndex].STATE = filling;
						fCAST_Proxy (O7_fill, &ID_PressureControl);
					}
					else
					{
						status_PressureControl.write_access_[currentid_.cushionIndex].STATE = equals;
					}
					break;
				case evacuate:
					if (SELF.observedPressure < IN.value)	/***  CONDITION isHigh  ***/
					{
						status_PressureControl.write_access_[currentid_.cushionIndex].STATE = evacuate;
					}
					else if (SELF.observedPressure > IN.value)	/***  CONDITION isLow  ***/
					{
						status_PressureControl.write_access_[currentid_.cushionIndex].STATE = filling;
						fCAST_Proxy (O7_fill, &ID_PressureControl);
					}
					else
					{
						status_PressureControl.write_access_[currentid_.cushionIndex].STATE = equals;
						fCAST_Proxy (O7_stop, &ID_PressureControl);
					}
					break;
				case filling:
					if (SELF.observedPressure < IN.value)	/***  CONDITION isHigh  ***/
					{
						status_PressureControl.write_access_[currentid_.cushionIndex].STATE = evacuate;
						fCAST_Proxy (O7_evac, &ID_PressureControl);
					}
					else if (SELF.observedPressure > IN.value)	/***  CONDITION isLow  ***/
					{
						status_PressureControl.write_access_[currentid_.cushionIndex].STATE = filling;
					}
					else
					{
						status_PressureControl.write_access_[currentid_.cushionIndex].STATE = equals;
						fCAST_Proxy (O7_stop, &ID_PressureControl);
					}
					break;
				default:
					break;
				}
				break;
			case observe:
				switch(status_PressureControl.read_access_[currentid_.cushionIndex].STATE)
				{
				case equals:
					{
						/* OPERATIONS before writing */
						/* updateObservedPressure */
						{
						SELF.observedPressure = IN.value;
						}
						status_PressureControl.write_access_[currentid_.cushionIndex].STATE = equals;
					}
					break;
				case evacuate:
					{
						/* OPERATIONS before writing */
						/* updateObservedPressure */
						{
						SELF.observedPressure = IN.value;
						}
						status_PressureControl.write_access_[currentid_.cushionIndex].STATE = equals;
					}
					break;
				case filling:
					{
						/* OPERATIONS before writing */
						/* updateObservedPressure */
						{
						SELF.observedPressure = IN.value;
						}
						status_PressureControl.write_access_[currentid_.cushionIndex].STATE = equals;
					}
					break;
				default:
					break;
				}
				break;
			default:
				break;
			}
		}
		break;
	default:
		return 0;
	}
	return 1;
}

/* Process Initialization Function */

void fINIT_PressureControl (void)
{
	int LOCAL_cushionIndex;
	for (LOCAL_cushionIndex = 0; LOCAL_cushionIndex < CUSHION_COUNT; LOCAL_cushionIndex++)
	{
		status_PressureControl.write_access_[LOCAL_cushionIndex].STATE = equals;
		status_PressureControl.write_access_[LOCAL_cushionIndex].observedPressure = 0;
	}
}		

/*********************************************************************
	End of Module for PROCESS PressureControl
*********************************************************************/
/* Actifsource ID=[e9267837-2596-11e1-ae2f-a14f3e396de6,2e7be38b-c77a-11ea-9e9f-c1d3048691bc,2e797237-c77a-11ea-9e9f-c1d3048691bc,2e7be3c2-c77a-11ea-9e9f-c1d3048691bc,2e7be389-c77a-11ea-9e9f-c1d3048691bc,2e7be388-c77a-11ea-9e9f-c1d3048691bc,2e797350-c77a-11ea-9e9f-c1d3048691bc,J3TyRE+4eoz5G6Spwf/vW+E+3DE=] */
