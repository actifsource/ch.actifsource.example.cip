/*******************************************************************
        SYSTEM ChairArray
        Module for PROCESS PumpControl
        Filename: PumpControl.c
        generated by CIP Tool(R)

        activated code options:
        	C code
        	use channel interface
        		naming option: use default prefix
        	'unsigned long' for delays
*********************************************************************/

/* Include Files */

#include "mChairUnit.h"

/* Process Macro Definitions */

#define IN (*in_)
#define SELF status_PumpControl.write_access_
#define STATUS (pStatus_PumpControl->read_access_)
#define TIME time_
#define VARIABLE (*variable_)

/* Process Enumerations */

enum eMODES_PumpControl
	{normal = 1};

enum eSTATES_PumpControl
	{multy = 1, single, standby};

enum eINPULS_PumpControl
	{IP_addListener = 1, IP_remListener = 2, TIMEUP_ = 3};
	

/* External Declarations */

extern unsigned long time_;
extern struct tTMQE_mChairUnit *tuhead_mChairUnit, *tutail_mChairUnit, *chhead_mChairUnit, *chtail_mChairUnit;
extern struct tCHNOUT_mChairUnit CHNOUT_mChairUnit;
extern struct tTIMING_mChairUnit TIMING_mChairUnit[2];
int fPULSE_Proxy (enum eOUTPLS_ name_,
  struct tID_Proxy *procid_);
void fSETTIM_mChairUnit (unsigned long *delay_, struct tTMEL_mChairUnit *timer_, struct tTMQE_mChairUnit *timeup_);
void fSTOPTIM_mChairUnit (struct tTMEL_mChairUnit *timer_, struct tTMQE_mChairUnit *timeup_);

/* Global Declarations */

static unsigned long delay_;
struct tPRINST_PumpControl IO_PumpControl;
union tSTATUS_PumpControl status_PumpControl;
const union tSTATUS_PumpControl *pStatus_PumpControl = &status_PumpControl;

/* Function Prototypes */

static int getListenerCount();
int fPULSE_PumpControl (enum eOUTPLS_ name_,
   union tOUTPLS_ChairCluster *data_);
void fINIT_PumpControl (void);

/* User Functions */

static int getListenerCount(){
       	int enabledIndexCount = 0;
       	int index;
       
       	for (index = 0; index < CUSHION_COUNT; index++){
       		if(SELF.vEnabledIndexArray[index]){
       			enabledIndexCount++;
       		}
       	}
       	return enabledIndexCount;
       }

/* Selector Functions */

static int fMANYSEL_selectProcess (int cushionIndex)	/* MANY-SELECTOR selectProcess */
{
if(SELF.vOldIndex == cushionIndex){
	return TRUE;
}
if(SELF.vCurrentIndex == cushionIndex){
	return TRUE;
}
return FALSE;
}
			
/* Multiple Cast Functions */

static void fCAST_Proxy(enum eOUTPLS_ name_)
{
	struct tID_Proxy ID_Proxy;
	switch(name_)
	{	
	/* MANY-SELECTOR selectProcess */
	case O10_triggerEnable:
		for (ID_Proxy.cushionIndex = 0; ID_Proxy.cushionIndex < CUSHION_COUNT; ID_Proxy.cushionIndex++)
		{
			if (fMANYSEL_selectProcess(ID_Proxy.cushionIndex))
			{
				fPULSE_Proxy(name_, &ID_Proxy);
			}
		}
		break;
	default: 
		break;
	}
}	
/* Input Channel Functions */

int fPULSE_PumpControl (enum eOUTPLS_ name_,
   union tOUTPLS_ChairCluster *data_)
{
	switch(name_)
	{
		/* INPULSE addListener */
	case O9_addListener:		/* PULSE CAST from PROCESS Proxy */
		{	
			tIndex IN = &data_->OUTPLS_Proxy.data_._tIndex;
			switch(status_PumpControl.read_access_.STATE)
			{
			case multy:
				{
					/* OPERATIONS before writing */
					/* setArrayIndex */
					{
					SELF.vEnabledIndexArray[IN] = 1;
					}
					status_PumpControl.write_access_.STATE = multy;
				}
				break;
			case single:
				{
					/* OPERATIONS before writing */
					/* setArrayIndex */
					{
					SELF.vEnabledIndexArray[IN] = 1;
					}
					delay_ =  1;	/* DELAY delayScheduling */
					status_PumpControl.write_access_.STATE = multy;
					fSETTIM_mChairUnit(&delay_, 
						&IO_PumpControl.timer_, 
						&IO_PumpControl.timeup_);
				}
				break;
			case standby:
				{
					/* OPERATIONS before writing */
					/* setArrayIndex */
					{
					SELF.vEnabledIndexArray[IN] = 1;
					}
					/* setCurrentIndex */
					{
					SELF.vCurrentIndex = IN;
					}
					status_PumpControl.write_access_.STATE = single;
					fCAST_Proxy (O10_triggerEnable);
				}
				break;
			default:
				break;
			}			
		}
		break;
		/* INPULSE remListener */
	case O9_remListener:		/* PULSE CAST from PROCESS Proxy */
		{	
			tIndex IN = &data_->OUTPLS_Proxy.data_._tIndex;
			switch(status_PumpControl.read_access_.STATE)
			{
			case multy:
				if (getListenerCount() > 1)	/***  CONDITION hasMultyListeners  ***/
				{
					/* OPERATIONS before writing */
					/* clearArrayIndex */
					{
					SELF.vEnabledIndexArray[IN] = 0;
					}
					/* findNextCurrentIndex */
					{
						int newIndex;
						int index;
					
						for (index = 1; index < CUSHION_COUNT; index++){
							newIndex = (SELF.vCurrentIndex + index) % CUSHION_COUNT;
							if(SELF.vEnabledIndexArray[newIndex]){
								SELF.vOldIndex = SELF.vCurrentIndex;
								SELF.vCurrentIndex = newIndex;
								break;
							}
						}
					}
					status_PumpControl.write_access_.STATE = multy;
					fCAST_Proxy (O10_triggerEnable);
				}
				else
				{
					/* OPERATIONS before writing */
					/* clearArrayIndex */
					{
					SELF.vEnabledIndexArray[IN] = 0;
					}
					/* findNextCurrentIndex */
					{
						int newIndex;
						int index;
					
						for (index = 1; index < CUSHION_COUNT; index++){
							newIndex = (SELF.vCurrentIndex + index) % CUSHION_COUNT;
							if(SELF.vEnabledIndexArray[newIndex]){
								SELF.vOldIndex = SELF.vCurrentIndex;
								SELF.vCurrentIndex = newIndex;
								break;
							}
						}
					}
					status_PumpControl.write_access_.STATE = single;
					fSTOPTIM_mChairUnit(&IO_PumpControl.timer_, 
						&IO_PumpControl.timeup_);
					fCAST_Proxy (O10_triggerEnable);
				}
				break;
			case single:
				{
					/* OPERATIONS before writing */
					/* clearArrayIndex */
					{
					SELF.vEnabledIndexArray[IN] = 0;
					}
					/* clearCurrentIndex */
					{
					SELF.vCurrentIndex = -1;
					}
					status_PumpControl.write_access_.STATE = standby;
					fCAST_Proxy (O10_triggerEnable);
				}
				break;
			default:
				break;
			}			
		}
		break;
	default:
		return 0;
	}
	return 1;
}

/* Timer Functions */

static void fTICK_PumpControl (void)
{
	if (IO_PumpControl.timer_.set_ &&
		IO_PumpControl.timer_.end_ == time_)
	{
		IO_PumpControl.timer_.set_ = FALSE;
		--TIMING_mChairUnit[1].set_;
		if (tuhead_mChairUnit != &IO_PumpControl.timeup_ &&
			!IO_PumpControl.timeup_.preced_ &&
			!IO_PumpControl.timeup_.next_)
		{
			if (!tuhead_mChairUnit)
			{
				tuhead_mChairUnit = tutail_mChairUnit = &IO_PumpControl.timeup_;
			}
			else
			{
				tutail_mChairUnit->next_ = &IO_PumpControl.timeup_;
				IO_PumpControl.timeup_.preced_ = tutail_mChairUnit;
				tutail_mChairUnit = &IO_PumpControl.timeup_;
			}
		}
	}			
}

static void fTUHNDL_PumpControl(void)
{
	struct tTMQE_mChairUnit *element_ = tuhead_mChairUnit;
	if (tuhead_mChairUnit == tutail_mChairUnit)
	{
		tuhead_mChairUnit = tutail_mChairUnit = 0;
	}
	else 
	{
		tuhead_mChairUnit = element_->next_;
		element_->next_ = 0;
		tuhead_mChairUnit->preced_ = 0;
	}
	switch(status_PumpControl.read_access_.STATE)
	{
	case multy:
		{
			/* OPERATIONS before writing */
			/* findNextCurrentIndex */
			{
				int newIndex;
				int index;
			
				for (index = 1; index < CUSHION_COUNT; index++){
					newIndex = (SELF.vCurrentIndex + index) % CUSHION_COUNT;
					if(SELF.vEnabledIndexArray[newIndex]){
						SELF.vOldIndex = SELF.vCurrentIndex;
						SELF.vCurrentIndex = newIndex;
						break;
					}
				}
			}
			delay_ =  1;	/* DELAY delayScheduling */
			status_PumpControl.write_access_.STATE = multy;
			fSETTIM_mChairUnit(&delay_, 
				&IO_PumpControl.timer_, 
				&IO_PumpControl.timeup_);
			fCAST_Proxy (O10_triggerEnable);
		}
		break;
	default:
		break;
	}
}

/* Process Initialization Function */

void fINIT_PumpControl (void)
{
	status_PumpControl.write_access_.STATE = standby;
	IO_PumpControl.timer_.set_ = FALSE;
	IO_PumpControl.timeup_.preced_ = 0;
	IO_PumpControl.timeup_.next_ = 0;
	IO_PumpControl.timeup_.proctype_ = 1;
	TIMING_mChairUnit[1].tkhndl_ = fTICK_PumpControl;
	TIMING_mChairUnit[1].tuhndl_ = fTUHNDL_PumpControl;
}		

/*********************************************************************
	End of Module for PROCESS PumpControl
*********************************************************************/
/* Actifsource ID=[e9267837-2596-11e1-ae2f-a14f3e396de6,2e7be38b-c77a-11ea-9e9f-c1d3048691bc,2e797237-c77a-11ea-9e9f-c1d3048691bc,2e7be3c2-c77a-11ea-9e9f-c1d3048691bc,2e7be389-c77a-11ea-9e9f-c1d3048691bc,2e7be388-c77a-11ea-9e9f-c1d3048691bc,2e7973ea-c77a-11ea-9e9f-c1d3048691bc,0TayJ+dxPry+u3f7Nbxtu+Lehd8=] */
