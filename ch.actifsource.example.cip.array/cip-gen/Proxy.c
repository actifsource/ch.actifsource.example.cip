/*******************************************************************
        SYSTEM ChairArray
        Module for PROCESS Proxy
        Filename: Proxy.c
        generated by CIP Tool(R)

        activated code options:
        	C code
        	use channel interface
        		naming option: use default prefix
        	'unsigned long' for delays
*********************************************************************/

/* Include Files */

#include "mChairUnit.h"

/* Process Macro Definitions */

#define ID (*id_)
#define OUTPULSE (*outpulse_)
#define SELF (*self_)
#define STATUS (pStatus_Proxy->read_access_)
#define TIME time_

/* Process Enumerations */

enum eMODES_Proxy
	{normal = 1};

enum eSTATES_Proxy
	{evacuate = 1, filling, readyEvac, readyFill, readyStop, stopped};

enum eINPULS_Proxy
	{IP_evac = 1, IP_fill, IP_stop, IP_toggleEnable};
	

/* External Declarations */

extern unsigned long time_;
extern struct tCHNOUT_mChairUnit CHNOUT_mChairUnit;
int fPULSE_Pump (enum eOUTPLS_ name_);
int fPULSE_Valve (enum eOUTPLS_ name_,
  struct tID_Valve *procid_);
int fPULSE_PumpControl (enum eOUTPLS_ name_,
  union tOUTPLS_ChairCluster *data_);

/* Global Declarations */

union tSTATUS_Proxy status_Proxy;
const union tSTATUS_Proxy *pStatus_Proxy = &status_Proxy;
static struct tPRSTAT_Proxy *self_;
static struct tID_Proxy currentid_;
static const struct tID_Proxy *id_ = &currentid_;

/* Function Prototypes */

int fPULSE_Proxy (enum eOUTPLS_ name_,
   struct tID_Proxy *procid_);
void fINIT_Proxy (void);

/* Multiple Cast Functions */

static void fCAST_Valve(enum eOUTPLS_ name_,
   struct tID_Proxy *txid_)
{
	struct tID_Valve ID_Valve;
	ID_Valve.cushionIndex = txid_->cushionIndex;
	switch(name_)
	{	
	case O9_evac:
	case O9_fill:
	case O9_stop:
		fPULSE_Valve(name_, &ID_Valve);
		break;
	default: 
		break;
	}
}	
/* Input Channel Functions */

int fPULSE_Proxy (enum eOUTPLS_ name_,
   struct tID_Proxy *procid_)
{
	struct tID_Proxy ID_Proxy;
	union tOUTPLS_ChairCluster OUTPLS_Proxy = {{(enum eOUTPLS_)0}};
	currentid_ = *procid_;
	ID_Proxy = *procid_;
	self_ = &status_Proxy.write_access_[currentid_.cushionIndex];
	switch(name_)
	{
		/* INPULSE evac */
	case O3_evac:		/* PULSE CAST from PROCESS PassengersControl */
	case O7_evac:		/* PULSE CAST from PROCESS PressureControl */
		switch(status_Proxy.read_access_[currentid_.cushionIndex].STATE)
		{
		case filling:
			status_Proxy.write_access_[currentid_.cushionIndex].STATE = evacuate;
			fPULSE_Pump (O9_evac);
			fCAST_Valve (O9_evac, &ID_Proxy);
			break;
		case readyFill:
			status_Proxy.write_access_[currentid_.cushionIndex].STATE = readyEvac;
			break;
		case stopped:
			{
				tIndex OUTPULSE = &OUTPLS_Proxy.OUTPLS_Proxy.data_._tIndex;
				/* OPERATIONS before writing */
				/* setIndex */
				{
				OUTPULSE = ID.cushionIndex;
				}
				status_Proxy.write_access_[currentid_.cushionIndex].STATE = readyEvac;
				fPULSE_PumpControl (O9_addListener,
				   &OUTPLS_Proxy);
			}
			break;
		default:
			break;
		}
		break;
		/* INPULSE fill */
	case O3_fill:		/* PULSE CAST from PROCESS PassengersControl */
	case O7_fill:		/* PULSE CAST from PROCESS PressureControl */
		switch(status_Proxy.read_access_[currentid_.cushionIndex].STATE)
		{
		case evacuate:
			status_Proxy.write_access_[currentid_.cushionIndex].STATE = filling;
			fPULSE_Pump (O9_fill);
			fCAST_Valve (O9_fill, &ID_Proxy);
			break;
		case readyEvac:
			status_Proxy.write_access_[currentid_.cushionIndex].STATE = readyFill;
			break;
		case stopped:
			{
				tIndex OUTPULSE = &OUTPLS_Proxy.OUTPLS_Proxy.data_._tIndex;
				/* OPERATIONS before writing */
				/* setIndex */
				{
				OUTPULSE = ID.cushionIndex;
				}
				status_Proxy.write_access_[currentid_.cushionIndex].STATE = readyFill;
				fPULSE_PumpControl (O9_addListener,
				   &OUTPLS_Proxy);
			}
			break;
		default:
			break;
		}
		break;
		/* INPULSE stop */
	case O3_stop:		/* PULSE CAST from PROCESS PassengersControl */
	case O7_stop:		/* PULSE CAST from PROCESS PressureControl */
		switch(status_Proxy.read_access_[currentid_.cushionIndex].STATE)
		{
		case evacuate:
			{
				tIndex OUTPULSE = &OUTPLS_Proxy.OUTPLS_Proxy.data_._tIndex;
				/* OPERATIONS before writing */
				/* setIndex */
				{
				OUTPULSE = ID.cushionIndex;
				}
				status_Proxy.write_access_[currentid_.cushionIndex].STATE = readyStop;
				fPULSE_PumpControl (O9_remListener,
				   &OUTPLS_Proxy);
			}
			break;
		case filling:
			{
				tIndex OUTPULSE = &OUTPLS_Proxy.OUTPLS_Proxy.data_._tIndex;
				/* OPERATIONS before writing */
				/* setIndex */
				{
				OUTPULSE = ID.cushionIndex;
				}
				status_Proxy.write_access_[currentid_.cushionIndex].STATE = readyStop;
				fPULSE_PumpControl (O9_remListener,
				   &OUTPLS_Proxy);
			}
			break;
		case readyEvac:
			{
				tIndex OUTPULSE = &OUTPLS_Proxy.OUTPLS_Proxy.data_._tIndex;
				/* OPERATIONS before writing */
				/* setIndex */
				{
				OUTPULSE = ID.cushionIndex;
				}
				status_Proxy.write_access_[currentid_.cushionIndex].STATE = readyStop;
				fPULSE_PumpControl (O9_remListener,
				   &OUTPLS_Proxy);
			}
			break;
		case readyFill:
			{
				tIndex OUTPULSE = &OUTPLS_Proxy.OUTPLS_Proxy.data_._tIndex;
				/* OPERATIONS before writing */
				/* setIndex */
				{
				OUTPULSE = ID.cushionIndex;
				}
				status_Proxy.write_access_[currentid_.cushionIndex].STATE = readyStop;
				fPULSE_PumpControl (O9_remListener,
				   &OUTPLS_Proxy);
			}
			break;
		default:
			break;
		}
		break;
		/* INPULSE toggleEnable */
	case O10_triggerEnable:		/* PULSE CAST from PROCESS PumpControl */
		switch(status_Proxy.read_access_[currentid_.cushionIndex].STATE)
		{
		case evacuate:
			status_Proxy.write_access_[currentid_.cushionIndex].STATE = readyEvac;
			fPULSE_Pump (O9_stop);
			fCAST_Valve (O9_stop, &ID_Proxy);
			break;
		case filling:
			status_Proxy.write_access_[currentid_.cushionIndex].STATE = readyFill;
			fPULSE_Pump (O9_stop);
			fCAST_Valve (O9_stop, &ID_Proxy);
			break;
		case readyEvac:
			status_Proxy.write_access_[currentid_.cushionIndex].STATE = evacuate;
			fPULSE_Pump (O9_evac);
			fCAST_Valve (O9_evac, &ID_Proxy);
			break;
		case readyFill:
			status_Proxy.write_access_[currentid_.cushionIndex].STATE = filling;
			fPULSE_Pump (O9_fill);
			fCAST_Valve (O9_fill, &ID_Proxy);
			break;
		case readyStop:
			status_Proxy.write_access_[currentid_.cushionIndex].STATE = stopped;
			fPULSE_Pump (O9_stop);
			fCAST_Valve (O9_stop, &ID_Proxy);
			break;
		default:
			break;
		}
		break;
	default:
		return 0;
	}
	return 1;
}

/* Process Initialization Function */

void fINIT_Proxy (void)
{
	int LOCAL_cushionIndex;
	for (LOCAL_cushionIndex = 0; LOCAL_cushionIndex < CUSHION_COUNT; LOCAL_cushionIndex++)
	{
		status_Proxy.write_access_[LOCAL_cushionIndex].STATE = stopped;
	}
}		

/*********************************************************************
	End of Module for PROCESS Proxy
*********************************************************************/
/* Actifsource ID=[e9267837-2596-11e1-ae2f-a14f3e396de6,2e7be38b-c77a-11ea-9e9f-c1d3048691bc,2e797237-c77a-11ea-9e9f-c1d3048691bc,2e7be3c2-c77a-11ea-9e9f-c1d3048691bc,2e7be389-c77a-11ea-9e9f-c1d3048691bc,2e7be388-c77a-11ea-9e9f-c1d3048691bc,2e79738f-c77a-11ea-9e9f-c1d3048691bc,yA64ksOFrrR/dK5QRrAp81yyYrU=] */
