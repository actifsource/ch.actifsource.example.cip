/*******************************************************************
        SYSTEM ChairArray
        Module for PROCESS Pressure
        Filename: Pressure.c
        generated by CIP Tool(R)

        activated code options:
        	C code
        	use channel interface
        		naming option: use default prefix
        	'unsigned long' for delays
*********************************************************************/

/* Include Files */

#include "mChairUnit.h"

/* Process Macro Definitions */

#define EXCEPTION return;
#define ID (*id_)
#define IN (*in_)
#define OUTPULSE (*outpulse_)
#define SELF (*self_)
#define STATUS (pStatus_Pressure->read_access_)
#define TIME time_

/* Process Enumerations */

enum eMODES_Pressure
	{normal = 1};

enum eSTATES_Pressure
	{maxPressure = 1, minPressure, normelPressure};


/* External Declarations */

extern unsigned long time_;
extern struct tCHNOUT_mChairUnit CHNOUT_mChairUnit;
int fPULSE_PassengersControl (enum eOUTPLS_ name_,
  struct tID_PassengersControl *procid_);
int fPULSE_PressureControl (enum eOUTPLS_ name_,
  union tOUTPLS_ChairCluster *data_,
  struct tID_PressureControl *procid_);

/* Global Declarations */

union tSTATUS_Pressure status_Pressure;
const union tSTATUS_Pressure *pStatus_Pressure = &status_Pressure;
static struct tPRSTAT_Pressure *self_;
static struct tID_Pressure currentid_;
static const struct tID_Pressure *id_ = &currentid_;

/* Function Prototypes */

void fICHAN_Evt_Pressure (enum eMSG_Evt_Pressure name_,
   union tDATA_Evt_Pressure *data_,
   struct tID_Evt_Pressure *chanid_);
void fINIT_Pressure (void);

/* Multiple Cast Functions */

static void fCAST_PassengersControl(enum eOUTPLS_ name_,
   struct tID_Pressure *txid_)
{
	struct tID_PassengersControl ID_PassengersControl;
	ID_PassengersControl.cushionIndex = txid_->cushionIndex;
	switch(name_)
	{	
	case O2_maxPressure:
	case O2_minPressure:
		fPULSE_PassengersControl(name_, &ID_PassengersControl);
		break;
	default: 
		break;
	}
}
static void fCAST_PressureControl(enum eOUTPLS_ name_,
   union tOUTPLS_ChairCluster *data_,
   struct tID_Pressure *txid_)
{
	struct tID_PressureControl ID_PressureControl;
	ID_PressureControl.cushionIndex = txid_->cushionIndex;
	switch(name_)
	{	
	case O2_limitPressure:
		fPULSE_PressureControl(name_, data_, &ID_PressureControl);
		break;
	default: 
		break;
	}
}	
/* Input Channel Functions */

void fICHAN_Evt_Pressure(enum eMSG_Evt_Pressure name_,
   union tDATA_Evt_Pressure *data_,
   struct tID_Evt_Pressure *chanid_)
{
	struct tID_Pressure ID_Pressure;
	union tOUTPLS_ChairCluster OUTPLS_Pressure = {{(enum eOUTPLS_)0}};
	int invalid_index_;
	if ((invalid_index_ = chanid_->cushionIndex) < 0 || chanid_->cushionIndex >= CUSHION_COUNT )
	{
		return;
	}
	currentid_.cushionIndex = chanid_->cushionIndex;
	ID_Pressure.cushionIndex = chanid_->cushionIndex;
	self_ = &status_Pressure.write_access_[currentid_.cushionIndex];
	switch(name_)
	{
		/* MESSAGE Pressure of INPORT Pressure */
	case C3_Pressure:
		{
			struct tCIPREC_tPressure IN = &data_->_tPressure;
		switch(status_Pressure.read_access_[currentid_.cushionIndex].STATE)
		{
		case maxPressure:
			if (SELF.currentPressure >= MAX_PRESSURE)   /***  CONDITION maxPressure  ***/
			{
				struct tCIPREC_tPressure OUTPULSE = &OUTPLS_Pressure.OUTPLS_Pressure.data_._tPressure;
				/* OPERATIONS before writing */
				/* setPressure */
				{
				SELF.currentPressure = IN.value;
				}
				/* setLimitPresure */
				{
				OUTPULSE.value = SELF.currentPressure;
				}
				status_Pressure.write_access_[currentid_.cushionIndex].STATE = maxPressure;
				fCAST_PressureControl (O2_limitPressure, &OUTPLS_Pressure, &ID_Pressure);
			}
			else
			{
				struct tCIPREC_tPressure OUTPULSE = &OUTPLS_Pressure.OUTPLS_Pressure.data_._tPressure;
				/* OPERATIONS before writing */
				/* setPressure */
				{
				SELF.currentPressure = IN.value;
				}
				status_Pressure.write_access_[currentid_.cushionIndex].STATE = normelPressure;
				fCAST_PressureControl (O2_limitPressure, &OUTPLS_Pressure, &ID_Pressure);
			}
			break;
		case minPressure:
			if (SELF.currentPressure >= MIN_PRESSURE)   /***  CONDITION minPressure  ***/
			{
				struct tCIPREC_tPressure OUTPULSE = &OUTPLS_Pressure.OUTPLS_Pressure.data_._tPressure;
				/* OPERATIONS before writing */
				/* setPressure */
				{
				SELF.currentPressure = IN.value;
				}
				/* setLimitPresure */
				{
				OUTPULSE.value = SELF.currentPressure;
				}
				status_Pressure.write_access_[currentid_.cushionIndex].STATE = minPressure;
				fCAST_PressureControl (O2_limitPressure, &OUTPLS_Pressure, &ID_Pressure);
			}
			else
			{
				struct tCIPREC_tPressure OUTPULSE = &OUTPLS_Pressure.OUTPLS_Pressure.data_._tPressure;
				/* OPERATIONS before writing */
				/* setPressure */
				{
				SELF.currentPressure = IN.value;
				}
				status_Pressure.write_access_[currentid_.cushionIndex].STATE = normelPressure;
				fCAST_PressureControl (O2_limitPressure, &OUTPLS_Pressure, &ID_Pressure);
			}
			break;
		case normelPressure:
			if (SELF.currentPressure >= MAX_PRESSURE)   /***  CONDITION maxPressure  ***/
			{
				/* OPERATIONS before writing */
				/* setPressure */
				{
				SELF.currentPressure = IN.value;
				}
				status_Pressure.write_access_[currentid_.cushionIndex].STATE = maxPressure;
				fCAST_PassengersControl (O2_maxPressure, &ID_Pressure);
			}
			else if (SELF.currentPressure >= MIN_PRESSURE)   /***  CONDITION minPressure  ***/
			{
				/* OPERATIONS before writing */
				/* setPressure */
				{
				SELF.currentPressure = IN.value;
				}
				status_Pressure.write_access_[currentid_.cushionIndex].STATE = minPressure;
				fCAST_PassengersControl (O2_minPressure, &ID_Pressure);
			}
			else
			{
				struct tCIPREC_tPressure OUTPULSE = &OUTPLS_Pressure.OUTPLS_Pressure.data_._tPressure;
				/* OPERATIONS before writing */
				/* setPressure */
				{
				SELF.currentPressure = IN.value;
				}
				/* setLimitPresure */
				{
				OUTPULSE.value = SELF.currentPressure;
				}
				status_Pressure.write_access_[currentid_.cushionIndex].STATE = normelPressure;
				fCAST_PressureControl (O2_limitPressure, &OUTPLS_Pressure, &ID_Pressure);
			}
			break;
		default:
			return;
		}		
		}
		break;
	default:
		return;
	}
	return;
}
		
/* Process Initialization Function */

void fINIT_Pressure (void)
{
	int LOCAL_cushionIndex;
	for (LOCAL_cushionIndex = 0; LOCAL_cushionIndex < CUSHION_COUNT; LOCAL_cushionIndex++)
	{
		status_Pressure.write_access_[LOCAL_cushionIndex].STATE = normelPressure;
		status_Pressure.write_access_[LOCAL_cushionIndex].currentPressure = 0;
	}
}		

/*********************************************************************
	End of Module for PROCESS Pressure
*********************************************************************/
/* Actifsource ID=[e9267837-2596-11e1-ae2f-a14f3e396de6,2e7be38b-c77a-11ea-9e9f-c1d3048691bc,2e797237-c77a-11ea-9e9f-c1d3048691bc,2e7be3c2-c77a-11ea-9e9f-c1d3048691bc,2e7be389-c77a-11ea-9e9f-c1d3048691bc,2e7be388-c77a-11ea-9e9f-c1d3048691bc,2e797302-c77a-11ea-9e9f-c1d3048691bc,wA9xzehBjVK4BvA2bf0IeAgfn5M=] */
