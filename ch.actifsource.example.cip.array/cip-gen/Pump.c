/*******************************************************************
        SYSTEM ChairArray
        Module for PROCESS Pump
        Filename: Pump.c
        generated by CIP Tool(R)

        activated code options:
        	C code
        	use channel interface
        		naming option: use default prefix
        	'unsigned long' for delays
*********************************************************************/

/* Include Files */

#include "mChairUnit.h"

/* Process Macro Definitions */

#define SELF status_Pump.write_access_
#define STATUS (pStatus_Pump->read_access_)
#define TIME time_
#define isSingleOrMulty() TRTAB_isSingleOrMulty \
	[status_PumpControl.read_access_.STATE - 1] != 0

/* Process Enumerations */

enum eMODES_Pump
	{normal = 1};

enum eSTATES_Pump
	{evacuate = 1, filling, stopped};

enum eINPULS_Pump
	{IP_fill = 1, IP_stop = 2, IP_evac = 3};
	

/* External Declarations */

extern unsigned long time_;
extern struct tCHNOUT_mChairUnit CHNOUT_mChairUnit;
extern union tSTATUS_PumpControl status_PumpControl;

/* Global Declarations */

union tSTATUS_Pump status_Pump;
const union tSTATUS_Pump *pStatus_Pump = &status_Pump;
const static unsigned char TRTAB_isSingleOrMulty[3] =      /* [PumpControl states] */
	{1, 1, 0};


/* Function Prototypes */

int fPULSE_Pump (enum eOUTPLS_ name_);
void fINIT_Pump (void);

/* Input Channel Functions */

int fPULSE_Pump (enum eOUTPLS_ name_)
{
	switch(name_)
	{
		/* INPULSE evac */
	case O9_evac:		/* PULSE CAST from PROCESS Proxy */
		switch(status_Pump.read_access_.STATE)
		{
		case filling:
			status_Pump.write_access_.STATE = evacuate;
			CHNOUT_mChairUnit.message_.CHAN_Act_Pump.name_ = C2_Evac;
			OUT_.Act_Pump(CHNOUT_mChairUnit.message_.CHAN_Act_Pump.name_);
			break;
		case stopped:
			status_Pump.write_access_.STATE = evacuate;
			CHNOUT_mChairUnit.message_.CHAN_Act_Pump.name_ = C2_Evac;
			OUT_.Act_Pump(CHNOUT_mChairUnit.message_.CHAN_Act_Pump.name_);
			break;
		default:
			break;
		}
		break;
		/* INPULSE fill */
	case O9_fill:		/* PULSE CAST from PROCESS Proxy */
		switch(status_Pump.read_access_.STATE)
		{
		case evacuate:
			status_Pump.write_access_.STATE = filling;
			CHNOUT_mChairUnit.message_.CHAN_Act_Pump.name_ = C2_Fill;
			OUT_.Act_Pump(CHNOUT_mChairUnit.message_.CHAN_Act_Pump.name_);
			break;
		case stopped:
			status_Pump.write_access_.STATE = filling;
			CHNOUT_mChairUnit.message_.CHAN_Act_Pump.name_ = C2_Stop;
			OUT_.Act_Pump(CHNOUT_mChairUnit.message_.CHAN_Act_Pump.name_);
			break;
		default:
			break;
		}
		break;
		/* INPULSE stop */
	case O9_stop:		/* PULSE CAST from PROCESS Proxy */
		switch(status_Pump.read_access_.STATE)
		{
		case evacuate:
			if (isSingleOrMulty())
			{
				status_Pump.write_access_.STATE = evacuate;
			}
			else
			{
				status_Pump.write_access_.STATE = stopped;
				CHNOUT_mChairUnit.message_.CHAN_Act_Pump.name_ = C2_Stop;
				OUT_.Act_Pump(CHNOUT_mChairUnit.message_.CHAN_Act_Pump.name_);
			}
			break;
		case filling:
			if (isSingleOrMulty())
			{
				status_Pump.write_access_.STATE = filling;
			}
			else
			{
				status_Pump.write_access_.STATE = stopped;
				CHNOUT_mChairUnit.message_.CHAN_Act_Pump.name_ = C2_Fill;
				OUT_.Act_Pump(CHNOUT_mChairUnit.message_.CHAN_Act_Pump.name_);
			}
			break;
		default:
			break;
		}
		break;
	default:
		return 0;
	}
	return 1;
}

/* Process Initialization Function */

void fINIT_Pump (void)
{
	status_Pump.write_access_.STATE = stopped;
}		

/*********************************************************************
	End of Module for PROCESS Pump
*********************************************************************/
/* Actifsource ID=[e9267837-2596-11e1-ae2f-a14f3e396de6,2e7be38b-c77a-11ea-9e9f-c1d3048691bc,2e797237-c77a-11ea-9e9f-c1d3048691bc,2e7be3c2-c77a-11ea-9e9f-c1d3048691bc,2e7be389-c77a-11ea-9e9f-c1d3048691bc,2e7be388-c77a-11ea-9e9f-c1d3048691bc,2e7973ba-c77a-11ea-9e9f-c1d3048691bc,VTJwANyxBrWCkqihpBdvjGsShKA=] */
