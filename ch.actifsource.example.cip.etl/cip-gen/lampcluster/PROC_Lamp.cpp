/*********************************************************************
	SYSTEM LampSystem_ETL based on etl statemachines
	IMPLEMENTATION LampImpl_c
	cip process Lamp file for PROCESS Lamp
	Filename: PROC_Lamp.cpp
	generated by CIP Tool(R)
	
	activated code options:
		C++ code
		use message interface
	            naming option: channel  prefix
	        all types in shell
	        'unsigned long' for delays
*********************************************************************/

#include "PROC_Lamp.hpp"
#include "../ciplibrary/CipCommon.hpp"

/* Begin Protected Region [[Debug]] */
#define CapnostatActionInitiator_DBG_ON   // uncomment for debug or put in preprocessor
/* End Protected Region   [[Debug]] */
#ifdef CapnostatActionInitiator_DBG_ON
  //#include "Debug.h"
  #define DEBUG_PRINT(...)        printf("      Process::Lamp: " __VA_ARGS__)
#else
  #define DEBUG_PRINT(...)
#endif

namespace lampunit::lampclustercluster
{
    /** constructors / destructors */
    PROC_Lamp::PROC_Lamp
    ( 
      etl::message_router_id_t routerid,
      lampunit::cipshell::INTF_ActionMessagePort& amp
    ):
    etl::hfsm {routerid},
    SELF(*this),
    STATUS(*this),
    m_amp{amp}
    {
      /** These are all of the states for this HSFM */
      static etl::ifsm_state* stateList[StateId::Number_Of_States]
      {
        &off_, // Init state
        &delayed,
        &on_,
      };
    
      etl::hfsm::set_states(stateList, SIZEOF_ARRAY(stateList));
      m_actualState = StateId::off_;  //InitState
    }
	
    /** Setup statemachine */
    void PROC_Lamp::Startup()
    {
      etl::hfsm::start(true);
    }; 
  
    /** Setup output */
    void PROC_Lamp::SetupOutput(OutputCb callback)
    {
      m_outputCb = callback;
    }

    void PROC_Lamp::publishOutpulses()
    {
    }

    /** timer extension functions */
    void PROC_Lamp::setTimer(unsigned long delay)
    {
      m_timer.setTimer(delay);
    }

    void PROC_Lamp::stopTimer()
    {
      m_timer.stopTimer();
    }
	
    ciplibrary::CipTimer& PROC_Lamp::getTimer()
    {
      return m_timer;
    }

    /*************************************************************************************************
    * Statemachines: Lamp 
    *************************************************************************************************/  
    
    // Macro for accessing the input data
    #define IN msg.m_value 
    #define SELF context
    #define STATUS context
    
    /*****************************
    * State: off_  
    ******************************/       
    /** Event on */
    etl::fsm_state_id_t PROC_Lamp::off_::on_event(const lampunit::cipmachine::mLampUnit_Inputs::Lamp_on_Pulse& msg)
    { 
      auto& context = get_fsm_context();
      context.m_actualState = PROC_Lamp::StateId::on_;
      DEBUG_PRINT("TRANSITION '1 on' Lamp.normal: STATE off_ -> on_  [d37d50bf-fb29-11ee-88af-c1ff99c74ce0]\n");
      {
        context.m_amp.f_C2_Bright();
      }
      
      return context.m_actualState;
    }   

    /** Unknown event*/
    etl::fsm_state_id_t PROC_Lamp::off_::on_event_unknown(const etl::imessage& msg) 
    {
      auto& context = get_fsm_context();
      if (msg.get_message_id() < lampunit::cipmachine::mLampUnit_Inputs::sLampUnit_EventId::_SIZE_OFF_MESSAGE) {
        DEBUG_PRINT("UnknownEvent ---> State: Lamp.off_:%u ---> Event Id:%u", context.m_actualState, msg.get_message_id());
      }
      return context.m_actualState;
    }
    
    /*****************************
    * State: on_  
    ******************************/       
    /** Event off */
    etl::fsm_state_id_t PROC_Lamp::on_::on_event(const lampunit::cipmachine::mLampUnit_Inputs::Lamp_off_Pulse& msg)
    { 
      auto& context = get_fsm_context();
      context.m_actualState = PROC_Lamp::StateId::delayed;
      DEBUG_PRINT("TRANSITION '2 off' Lamp.normal: STATE on_ -> delayed  [d37d50c2-fb29-11ee-88af-c1ff99c74ce0]\n");
      context.setTimer(3);    //  DELAY DELAY_OPERATION
      
      return context.m_actualState;
    }   

    /** Unknown event*/
    etl::fsm_state_id_t PROC_Lamp::on_::on_event_unknown(const etl::imessage& msg) 
    {
      auto& context = get_fsm_context();
      if (msg.get_message_id() < lampunit::cipmachine::mLampUnit_Inputs::sLampUnit_EventId::_SIZE_OFF_MESSAGE) {
        DEBUG_PRINT("UnknownEvent ---> State: Lamp.on_:%u ---> Event Id:%u", context.m_actualState, msg.get_message_id());
      }
      return context.m_actualState;
    }
    
    /*****************************
    * State: delayed  
    ******************************/       
    /** Event on */
    etl::fsm_state_id_t PROC_Lamp::delayed::on_event(const lampunit::cipmachine::mLampUnit_Inputs::Lamp_on_Pulse& msg)
    { 
      auto& context = get_fsm_context();
      context.m_actualState = PROC_Lamp::StateId::on_;
      DEBUG_PRINT("TRANSITION '3 on' Lamp.normal: STATE delayed -> on_  [d37d50c5-fb29-11ee-88af-c1ff99c74ce0]\n");
      context.setTimer(3);    //  DELAY DELAY_OPERATION
      
      return context.m_actualState;
    }   

    /** Event TIMEUP_ */
    etl::fsm_state_id_t PROC_Lamp::delayed::on_event(const lampunit::cipmachine::mLampUnit_Inputs::Timeup_event& msg)
    { 
      auto& context = get_fsm_context();
      context.m_actualState = PROC_Lamp::StateId::off_;
      DEBUG_PRINT("TRANSITION '4 TIMEUP_' Lamp.normal: STATE delayed -> off_  [d37d50c6-fb29-11ee-88af-c1ff99c74ce0]\n");
      {
        context.m_amp.f_C2_Dark();
      }
      return context.m_actualState;
    }   

    /** Unknown event*/
    etl::fsm_state_id_t PROC_Lamp::delayed::on_event_unknown(const etl::imessage& msg) 
    {
      auto& context = get_fsm_context();
      if (msg.get_message_id() < lampunit::cipmachine::mLampUnit_Inputs::sLampUnit_EventId::_SIZE_OFF_MESSAGE) {
        DEBUG_PRINT("UnknownEvent ---> State: Lamp.delayed:%u ---> Event Id:%u", context.m_actualState, msg.get_message_id());
      }
      return context.m_actualState;
    }
    
  
} // namespace lampunit::lampclustercluster

/* Actifsource ID=[cfa71961-cf03-11ee-91c0-c5a9ed07c9d7,d37d50e5-fb29-11ee-88af-c1ff99c74ce0,d37d50a8-fb29-11ee-88af-c1ff99c74ce0,e83fa4af-fb29-11ee-88af-c1ff99c74ce0,d37d50e4-fb29-11ee-88af-c1ff99c74ce0,d37d50e3-fb29-11ee-88af-c1ff99c74ce0,d37d50e2-fb29-11ee-88af-c1ff99c74ce0,d37d50d8-fb29-11ee-88af-c1ff99c74ce0,FmFA1nss56ieuHdVJ1ojJiit5cw=] */
